<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据的离散化</title>
    <url>/2020/data-discreatization/</url>
    <content><![CDATA[<h2 id="数据的离散化处理"><a href="#数据的离散化处理" class="headerlink" title="数据的离散化处理"></a>数据的离散化处理</h2><p>什么是<strong>离散化</strong>？</p>
<p>离散化，把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。</p>
<p>通俗的说，离散化是在不改变数据相对大小的条件下，对数据进行相应的缩小。例如：</p>
<ul>
<li><p>原数据：1,999,100000,15；处理后：1,3,4,2；</p>
</li>
<li><p>原数据：{100,200}，{20,50000}，{1,400}；处理后：{3,4}，{2,6}，{1,5}；</p>
</li>
</ul>
<p>例子：洛谷P1908，树状数组求逆序对时的应用</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1908">https://www.luogu.com.cn/problem/P1908</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>2020-01 日记</title>
    <url>/2021/diary-2021-01/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="【■■■ - 密码错误 - ■■■】" data-whm="Oh, these decrypted content cannot be verified, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="8854ce45198226ebe77701aa534baa91bfbffbb724a7e9b05decefa24a5e4069">2827033f81fcfb979d6a35f655f74dad666f139907e7dd6158a7a05612428cef9ff45436822365c02cce6cfd140a623728282b35589f56be98caea44936210eb800693a5d9671c9d5f95ab1b09d60e3c377cd879653ccc15086cfe51b8a72140cac2bbe82f6fdfba3450bd3076a705c6d00ffc7492fc3a9ad4ffea8af7027bf57560749bc3d1325fd0bbddc2ff786958a3c9ad2cf793377f537a668d8dfe863803b26f8056d7ffc72dc5cd352c660afd07869e7b60902fd4346c033441c9cd2bc8ac6ff89f6946876deedf4108f55035ce5d47bf7d252caaeccc6d06e795a1e7f35d4283fbd807bdc68db607c4e4f04db62607c44a6e300d56324f9d64c870b4f6b174ed00fb7e84411d4a3fcf0c307ca99719b9686b9b1db85bd10aa09c2cc7c82f2501f133db7e21ac743e122f002da386e6ce54ef86a8fb5c4d83db22fb4c2c3ee4026e6583e71d39826d9f152aff700ae244a4c1ad9f99ddf49b1cd93341d33d3e7e9b96eee25a5680826807acaf52d87752038c3aa68617706fae8b01ca3c814f67d96405af76348c255a83f21bfa25c9f90c1907c044240dd98dec0990e6aa2f54833b149c8ff5b2cabdf458ae07579d4309d5aca935cc2ee26a86e00ae685253ceb6c5ac87e5c69f1ee5afd8e2eb5cea4b31d813f9cd09a3fa9cdb9000c314dbddc6c3443f07d31745665dcdffe5a7dc009dba55e73f9d9a3d025904e68cab3053857b25e1eff82540da929908c9db0cb6fa9ad12bf9a31634979666a0c74918abc244fee532daf91dcf0d118fd7af272fa4cb1b85d6f0d8dc77b3a5be366b450633fb3398461ca152330fc3b4e9c43bacdebc3afcb1e589b4c5df041cdf9d170290a3e80ebcc45a07bc4daa3b7c8046b4d5cf4289f731ef410463a2050bc79a7c2595d6cd4d04603dbbad769200fd43e72dd6c9681b4bab3003020e1dbac733ec731ee49740b9107134d09250b0a6630caa4ff8fcd7448c06565fb68ef4b4071c206c75756706ac1ad4cdadab464594cee304cbaa40d893b5ed4ecc5ea4c660381edcf0d096844ea7985661d7c83424f7f89d7c4eaa3011974443d531085c7cf7b4230e9ffeb8cefd11b2900f8685d3236ca9a8e603b2e2cfd1fa151804609b0fddc751f78dacc11b0404b9ebe90933acc92f29ff8d0cec66f7fd56edc582d13fe05e00e5d3ee15ee6b102145f43145928338f3788da3725d7643d8ebe303121fe8004ac2ba0af276eababb871415a54061ee0ed00f6a9da0dbeb8fda5deda9cecafd6cb5e22f9d95f78912c27fd83a65ad6e0d0c9b8b0d778253920df326666f50f2fe18a6053bc80f1de7ecfe4b52fd3a857f6ab9e68d034276b296f73e667db0592738ee68116bb7491126c33213274cc440195f5707baae9594f83863dcc47a206cad63879960559dfae6bc6da4f00eebedfcfd0d426bb5206f4fbd83bfd8397202bf52cee32959706fcd9420d1debe5b124a4c99eb1a6dc2321d4677bab98cfe5a35f8ba301a670cf81835b4dabcc7c65b8dace9d05bd614f2d14800315c0b23a5da0b04ecec536775e49ddad9136b38e61063c0c582be9c8cdc4f354b7dad56e108bb2ce31824bd5e59ecbe4335668d676f545f7388e220396cd0bb5de20e96f5288821affbebfc385d4ac6870cf5cfb51ac5b2cb3067b3544e8d1a646f66ca17c4e4887050e7ce58578e2dbea68f1b41b03160696684e9e57e4052b9b13dc294a01b2bff2fbfa19823f65e6036d006edadd5106ffb8935c93fec079421c3562be89b7bab84229de3dd13f30de112a44ac550975d6403dfe67d9b3f97e3e74967b8a6b2d74d3471ab334ab09979b202d48c97a25a016cc0e752b08173a0036ef059b81b3c08c1009d44c11d611a5a0120e8bd80ebdd0f4b78ea5ede196861cfd32bd4517389dc80bd080422f90b41fad35dedaa87b67c9f2a6deb10374a707d8222cfcbc3ff0dd2acf63837014756f7cecfdcb48b1a48e76e2551e0e9ef48c40aebf43fd7dc482e4971a9d242a64c53a4d49f5c6b0eef858f4e5596e8be1074f4619b21d13546915128d4007f252345b9fae372d4eb85a03f718942a29dfd528fc372e599a64f9b6e2e3dcef5fa1da91330d856f861eff6007407941706885f36fb6406480327701b93b5dcf37051ad2516970826c8aaf260fa9d908c633afe5b2b914964dbc5d396dad1c50115f9e44ffab4d9c6134c5fb38a02a0565b37275eb459344f294cb8ddf3daa75cd764a79509cea992ec86f2ff07ebe91985203e2d8b2dc9c9106e2d008ef8c9315e669a995583b66ee3dcee84b15691dcef3cfece65f19ceb329c88dc601701d996167fc329a9f5f5e81f6cb4416a9dc378e744a1a1474be3300c2a9f4f4bd6b75c34b9a083649e8e42cf4751930e0d2bbe52eab7cfd9b958242737eb236806604188d0327175aebcf45a24d40cb1d22458907a04d5c0aeedbd3bb45190b8124ee271986f400d0d2e525167bcb8ae1a5068521c0f2a5308cceea81eb52d4d4e1cc6b68c3a6a7da60b472a19373ffc1bc0c0f42a3d0eca0786d389deda1440f4e168cb08ee989bfa500ee5577305a12ffe3c8fc3af4073a893ce550d9d355d4b5e752d5b4da18b5f25ac83da2561718bb95746da12b6af48dc1c8a920107098e003ebc00fbbf38e26a215dff807762ec1a5c4843960f8f1d40f3ca17b11a4a87f675f56028e14f0e136c7374aa2dbe8bab5f9b4b2ca7f07ab1c03fcbd6e4120273db7c692917d5d2516b04a4ef72ac8c4d05c11eb5cb8e48b3879c773572e6fe7adf7a79bc00e15bb7166197587c5e06927c2b08943d008602c58db62bd253b6fda0883a28130021ef0147ce971d1af7b31938de90f5231712689b95e4c71a2a578aa7354451bacbfb5d4aae99a4d0847568996ba63e61ecbf097e03112c8889bbef35ba332bb4c958e0ca0109b096eec691d248d02e2b545f8a14f1a7d1989416336bf96ebfd74d00d95e05b682a4247451dc8f77bd11a7e33eb57a0bd8ab510263ae993348324da987f4f27be5160eded259dc3d34d96f662a3f0889579f422488494fe711bfe87ff62b606aa325033da5f48f7e59be4a47b852729785f1a4bf70def5a3721efd898181afa2a2e914b4182bd170e82056ef309ef4ba66127a0e441989980546acef76b3f7bba65e0e3f67b4c491f4b278a7e608b619886cd144696662a0075e14af61faac000374ef62043c6cae2297d8b8616d6b315df54c26b82d8092ffba9d8c68499366c2a47c1313f625fee640c56a5a912bed28e5ece1f9d2aeafa14f1a044757c2b639c4d3cd93e43c4b97ed25782609e70ca66423570dfbbede851631e5e78e4f7389d815899c024fcd48dc0e3ddbcff8dd53cff74d21f28a686b50246a3ab4b56c9d741d4e7f3dd1830915660679ac3829ba4c940cc59963f4fc86ffedc88c8b4641ceb238588762565f960b65260828e9c619a2d0370ca192d96abf6017c136275360dea9afc5040d0ef71e897f210c290ca1e97fb12a1e47069242536e5530458743299261917fb9a185a90a0eb0570e5f261167a5709f5e2692b757a0cc57496d970e916877bab60a136a8b91972d762ab5d151e48f3c2eacad5c2dec2a812fd51adf24bbe17a8e770c411287af83857ae2c7cbadcd458c8a6e36bea8f1ca13764216972b6e5c729ed9801b1752ae8d8c8e0ba989f4736c92da7570a19c53d7f91be39871ac25e2be700ec9207547a32a2602ee83c0c7521ee7c24e7255adfdf991b80508c5b7239caf881646171a0ffd72cb6bdcf6be04880efa021b07bcd4bc9f73c70d89c22deb77c25ad8fd8881069c09ffbbedce5bb3268372206882d2dc6219ee66872d42b2ae003278536dab9c366893256e22e641c3a196ae115980d76fba84a69c41f97902b1ad1c58455c323f8cc8132695bb4b7f0945c9c614ef02006c30b608856f6a7f3f81f9ac652ff0e01556afe6ddf500628e819b0efd2facfb2b7fc08b11ce227c5ceb1a6bdc236a0f314015254a735ca487a7ad5e13adffe68fbdbd18b8b0307dbbbc145e73f9613a1803e54054fc06f3d02cc6c456010dc156293a41c8965156c7183d5714dd6087521b6e432196645c9234271aaefa37083cb5fdd42a05710b9049a5398c3d7aa8d265613b9e203e02f61e1cac5f5358661cc06ef2393932bb16966c8982ed79b8fb6a7ef36e77c7f93d74c7871dd030faa89d64b7fdc7e0ee765084a5bd972ce1402b89481cc2c70857a0798744c1c852eb0ccb6125b15a93f84eb868def647e82610661e6c5e8f5b2063898775da8940b4777b444ccc6cde96090f822090d73444f82c01403e907c9a3dacd63c35ba4795e748954563317b7ba9c5ffeaaf8e20b8d938cb2da6e5cbf4b6912e738369382f98ed05d0be119d7e33850b87cfd56fa703296c545398abf281cf90b58ecaa89cc9787bd713aea2f3fb4c4a9709a8f17d3fdab5006ff8aaf47d42580a39611cdab36118fa1ffc1084dc80f0befe56777465ccbef609f4b201da43cb1ec2c590b78cb8264361c530758c56f4a357fa1c1b2ee418518957d252366df2f081d044a41f86c535a66b1059590020a66cd0d6e30f02d1605ad926ede00536667edf7817b0d828954f409401e3d376bef238cc3b94b91ceeefe5dda648ecaf9d693c69c6f31cc51fb4a61041b951696d9c5e4574bed535056a91f989d6a37ab25254efa9440ce453045140febdb6a8bfebaaa0776247c364a0ab02b5d48ed56d1e4df6da27cd75644de11856e89ad92011e478fe9313ecaaf10b6fc62a621d24ac7b755972b9f37149452e417943255cc33913738614be0009ed6154a1ee935009cdc6140a36614cba6eb41bea2695e2b777b4746dd13cdb56a920661d4e32a7b44e612699c9e6e30356ea9c2f12d05b4ff1303de24016cb32528c119093c0dd5535364849cea36f68714d7a9ef1435e35efae6f0423f953b6b30658de5e2d5a3789e52806104fdc217734e52fdec3a2ad072834e069160dd4834d6e287082c12b8cc8c51c399781565e4bffcd27dc25b5f7a9a8aa60141b1f318a6b30ee55d1f8ba372ff8d2cf42d42e2a89152b31acb66cf267966c0b7ec1d4539483597928fe15de61614a82ed87390039c0d7a7e5e96eda360bcc060a845c94bfd8ec01b57d6524f221edbc3d10d227c6e8c25f778e3d83146e6d942372bf62cc5bbdacc6ed8220810ddd4ba6040be1f08a05d6db155f4945812d0fd7418d68914c0a6053f3ded550d8d0e109265ad5e8f390b292018c3f7620d86af1f6a279ecd54ff4ffda12efd95ec527fe25f0b7ac5cd5d59a50a08eacfa536a65949e4eaf4671e0b9bbdf251d01cc299ab94299fea04df085b3380a6d47812a6b8cb3e23795c1d13dee416977060bfe581998a4ac9a4a5621466831faae3c7d0c67a196677f6abd52810555cfbf68680e50fb2fec7e85b46c5acb68c99ab90d577f1a72a21d8a47d7ca5e5b974f7f050571970ada57f5a5c525ee60be5a5ac936a7569e8c0e8705b39398cd302f6fadacae1cf8124032c19a092ae9e231d8268036f2f4b6b914bccf4a126b117165604203fb75a820b90549005c351566944282418b8ae91fa2aa38efc587bf6736a52457cfe6e08036ab28e506bae41768913cbc353ed686a31e39ac0d46906b4e25538d282ea8929413d0452e7763f129fed11e592b8a0b2f0ae0158a8686ad20620082ab9c8bde4b519bab060af670b7cbef3625fd12e80e335a90054ea84be1ec493918638deee06a0a0bed2040952469671935048c186406bb615291465471b4f7039c7f93f3efae7ae991c913b8d488b3749b604cd9dd15c34c384f22c5dc49d7f028b033c5b1ad316083a02e7dadcf3dc84365a2e2d09e741e66ab0d303ab1ec48c8de6d7751b65f4d5ea9c2882be5e7d5fa2b8cafefb2b4eb5e03c21ddc4fe8981d2543b32d7be77819df0d0ab95a88fd9f0aea2f5ae08dc73da24b1f5ce18764d5b7acd796bacccaa239e7e9510ea2bc702356a4f6e002916991a0d5cb49e5ce185ed62b8ee17487dfadad92dae22dca82d4987fc5b804152d96387491cd1738835ec89f7c15378cb9dfca6a48babbd79a5541c1f3009f7495b2fb07f53abea551aa683cb5f66685fbe1af3e06981b6f905b95c051516c7a71511e7abd8f0c49905714064553a940a6a94c689fc20c68d68aee9b3f5bf2e162a6b5695e178a3c4c4ea5ab7bf17f6be3aa6e50e576097f01f6b6b42f89dfb509b85b59142f97e5df886c8241616cb8f81de7127217c9bd8518fd05fe6210a9e40404ef3f30618ecd8da4335db5ec9bbe4fa603a5dfa327d0cf46081134b54ebfd201491682665773d89dd61b67d47f56345d18b06bdb3bb24e8e4bf365edd76998cc10dd26556a3ebd205f0ad5ce408289ecebe2b7c7fe7dddbbab3b73ce516ac47786cabe5f55189e4bb1b7b4abf964d4b95f9dab08197e224b55dcc920c9d9107083ee5a4af23d4ea3cc52f334088a89148d3cd1821b93208872088629add2d4a089ba91e5605863b985a41966ceeaf9cb3e4deaf1b9a6e5abe95af7a3a847d8b73318b01583d8cfb172a7b42ac9a09453dac0b5df00adfc0204ddc8bc29cbab6349cc149c6dfea6e4e3187c3c0f30891f136d96d54271a5ee07bce06c637af6a3282f4fd30203cbca3e782993dff2af640434af37c4a5949c345299398c481c5d895c14e81142dc89dd0a639c0fdacc79c4906deb81f292ea262b37fc7f5c2c8da640dc29485559849de68cb6c98dacfa6361e2f1f1fe7ddfd5661f45eec8b7a69159dfc7b74d07e06e0cd3638cc7d8dcc18f46c972374942c79d131a5c83fde4c8aa48169ce823a98854b1b1e412626d181dc687fdd457e469e7afafa7bb1e51339ccee50e4e81458188e3589d380076fa579204a018eb4f28bf175b8f8a91795852325ae1ad8cd12e6dc0ae4f758c115572298cc36d013ba193560b45bc62decaa97576937854e367d5a1c4d5c7d0cbacca65c3eefd4682588e05f58b5204746fbd7beca1863ece2f2696bc04efc479d4c55530f30e1b3ca1cf9e41c5e86786663b0e258f62a59bd8f7b628fcba455b0fd059ca0f8b3bd0a8bb5c66a75a8571090d922cb1aa5346a015c6e0fd50f2ad676306beef52c37e05ace98b074a78d799b993ea517c8cb7312029ca4245e1db894fdd34cd4420c381c7cb5d2d7a42a0435ea131e2df7ed3a2fd2a0092a23945f709d4978db08b3fac51da67590bd347ff53058a882ab4381e4c4916a255c5e0743fba3418857f889639940bed2843b226680304220aa9a3d22b670cf2f1a3c01a261417f3098403937945372260f7648d37e33e2674bf89ad5244b358d2947087c0d3a8b42df276591030142071210676029982fe84a3f2658c9ad9acb3b78e170bd171a12d2929c74c5e36b8f76957bbfb14e5216762a0e5f2a86177a3a91e281ca0bfaa5a294740a3c28774b56b01ccbd71186010167e3061775a7635b1fd417f79c9fb25bb3ee9df54a83c3ce3122944880b866c54aeb85d8a93cd46a02e3b7d97098246099f4487e7b6a9221bc39f2bfd2e561448716b4feb8db6d7aed9d9a8090cee178c8e8f9137b1b89418f110d9c39e50b1d9b9149f9b1a346404f952661ec262ea84a2774875e2b7582f24a4978cc4c5fc342bfa4c737e93c5f52987e0a94b31ab74b9b3810d71275c03aec84028f4501ec9a057642a5d4115eab620dfde1654b7d98d637aceabfbeb616ab5864a8f5b76a40a3dd966c3d5b1df0192c76ae418c6093824f62aadfb31ae131c525d00a95c0535a52ab50dcfe2df22401dc8acff2e3e4e208aeb4f956f394b6c577f02a8e2d5c62eed70990fcf5f139ff87f39dac28c9fe828af09a44cafb45d18b46767086845c92e182e99a0301a6d031fc989ac8b9f1f1a3cd09d1aa673b81a9215b2ce933e1dec7ffd1d36d1bcececf1b6e010441312fc10878b785d63f0f560d3af7bbf7b73b4a580b8869a70fadbf89a12ad6e3750508dbd2aa04c760df02784c32bc3a3bd90bcd792c96e67c8bc2707de6fa6a8b85f5b9ff551ce74a648b1fe5b315ca4a079c49df95f14400b579549fe911a028eaafe79e9cffcf8e80cf382c927446545b0bf2f1aec4e5b225d5753fb1334c5cb53e9fe051085e5c9e036a3de49f7dc70db85004495b41a173772eb8d823878001b7901c85471a95076bda8e281d89a491c234902810e13426f8c09178f18c3699998c509750f5e6a258ae247f4a7a672aabea8ef1331e9962bd1da06b53f1903de23b4ae454e228c2a38462fbbc56256886644acd088bbaec2352dcc744a7763be41ef7b3f072d078bf379db24d161f73b1f6226a2f2b8a737f469c4d30759675f41a186350f420db461b422c5c0cce0834e89cdea14eb48059a6ebce89bf4f8faa868a31d77065d896f51834603995f79abc918b35c23169bcfa98dd10f1352932bd63df80192c20099b0a0de158aa37248c5240d6893845693b3cfa9d7cfb6f8248ddcb12ee164a85110b72f1ebc4ab2052b641afc4ef9f73f254640b5e2fb09edbee038c5680d6a4f0fec070b7f8f6b85393ae2036c53645fb93d6832dcc45ba8b56d038028204cdd62af7ee8cf6291aa6795fef4b792a9c9c97ed51f925305c8c1b8e640386e65919ade4c68a8a54fb2c2b6f914b83b8f8989ed61c7882ae428989da76783af979ac6e434bedb6f99747c1a8fdaef0349d4cbbb4493c9dd1602ca031e76eef12bdce857a15425c52250362c49a7ddbb0f3549d0a9f73cc18301db75ae06e70f768c4aad48df4419c95a255ee0fc00173004cb6a945af1f66480800dc9cc1268c3b32ce063f9745913d69e443f8a3483c3dcec184d5fe79eddf5ba5199f87c77004bed4afd4fcbdf72d882120f7c943642bb23f9aebc576b6d6c723fbc591e284dce0d024b3865e1752f742ea55a72a530d67c718a834a2e52c07a8e6b6d58a348fcdc5c103a05eed87979a16c0e4b3aea91465de2c4c8d8a27b9eb17e301f46aa4c7e7fcaa1b446658507101fa6625a2b34a6703d8c5face2b162b460596f9cdeb76ef5b7a692bea1c20b8615cec6cb5c786e0eb46eb06ec817a584bcabec470653a7d981d869f575c5be049978f827d398e286cbcf49f5f0f00fbfb58ae2613fa052c9ee78f858d2daa0bd86748183c0a3b5f6d4ca068f8f5aadf6dc17d7179280bd571e3a207a80e86a545bdc4d62172d5ce6609dd847e440ad4fe3bcf24536648610e9880c172409458676ed544e092f679a67975c56115aa32eb2bf16b5acce4e7dc506b673e0e7aa4eb6d4838f7ad7d05de03196b2f67c0c28fa61accea38fbd032bbb0741791263a502cf87dc00f885ae7a60406c3820c15ac335834a49f38dac4abda0d01975e06668d870b98ac6137f86eaaabe3366a5508393f5ef0450d238651cfc47163d6358cc21e06ac3fd29ace25d95a86c107495a177318b66b02293f48bbc88b7d752aea29d6a90493338849768549064363c536c009cd32378c84365d1ae9feaaeb97e2f88e6f5b24abf242554a1336084ddfa614cc321b4aba0780646dfded05b2311062fe038ffa5dec18f38e8be2d6dbd7ffd065fc969d2e238efd648349f2e0d64ff16562b32e022871f7e36508b6b03546820b414b1fe4ea8bfec89928e57139f59611cfe32bda42b036ae117ec072c87a16502a4a2ed381231403bead205553a800947882e5958baf9a35bcaae33b1e70c9310c880e74e041348e0b91b5f506a3c3f81275d5c3acbeebc07c49bf8504dcf9176d60c2ad364e88ca8a03bd5a971e6ed991b425245992f5b8fb10643ef94ed88857c44c5d419ceeed1768e14ba37c6847afeaacae0902b1a16ba16936ec001cf93962629fb286b9300472e2a492f440555dbcef4d7942665f1a724fd132c1ac427fee1e0d6af38cfaf22bfecbf3c4167815651e4259e35a66360b55d8c906fa54a7d71a3b82e9191271733e58c64124c05044e193eb359f54213ff8cf6b4b906e61314d68cfd1cbbdaba03646cbe4e901eb57060f3b24dcfddeab435b401bd3f99f756273df3ff4d7408b1dd6d71280736eda8ef907a2f7d7337b93ad045bf7f3cadbec145f8df71134d9190627c59816a7730886e791d71bd49126ba7440c31f6602df46527a43038e1636ad10fe6a3c89d7829bc42434187111d933a7456382f7d06775c5d761174494ae89fa3f63ffb26662fb7487403b61cc2b501ac539846b721c2ec988114a53ff7863279189e53bb707e07e2ec2fd1860cba2578f1e5516a30da61f4383fe4b91569d249d425e64ed7c268164c96e4bcd6b87fa9b997eee635ee42db53c3c5377f3843d45e772aa875b2d90aae05e19f75680f9730039cdf1c9e3208def3f5d2339633f061b9f2b70faff02933e19eb55b5dc05cf9c3baf024e62f514bf76f8ece1caf9c0706cd92ae155ad2b849c903a3113cc8fa9a1c052be6c408606a6700bcd184ac7e57ab56b95e6234b583ceed631f79b5525e1cac5333498c97dadac31d87b2b73773d7ee3dc0ad01fbc5a8e641bee55c9f07cf9df93beacf822ffb8cdac71e8036df72187175d7358eab5fed634bfafeb84036ba27749657c5debefc85d5691c5e0de29cf338c1a72da66da87a484c43377cb53e38964c03b70f5b44caee7318f2295b844afc4708e60c8aab93081a57270f266ff596326b592dce60076ffc51fe4a5ae3de1459d635d787635a3d29007a89a5cdd6f25d32377aaf573face16b70db2247091c8559ed1d4e23df9c6da78d5b4fe7b6b52f5f8de931e82975db29f3d087a554f89584e852c8a2cb46859ec61446783b00fd6460d4387b02828c6a91a83e09bcc5d87703ea08b74c380386511b723207058ffe516f5474b495bd4fcde3939dd875973cce29da364a37046fd63782c0b2265930db4f42875075cd13b4291a8dd0822f225591e779d0d66e95a93a6e29cc650f79470d3e1d8fc140b133bc77aeec622365308ce644a5d2da3290633f192d095a07450792464c37990f84df9699fdbba56d670246e36cf5a4738ddd86b8a2cdd79bcb51d9354e0dae7cffec9377f645f68ccb0c76a78aa2f987d96f72d4765cdd72d258a0e2f73f7861e139f841fe4391ec0c3da71ac79425729b6ce5a97598c9020508cc049f456736d3e10d3813a2342fd988f3fbb572bb52ec5443c17dd3b068246ff3b90be4a4ddac98fe37d2421a38ebeb262d7db0aabd7eea918c60f43f6dbd6b97a24f26fbaacaeb207d55455e49c9869b96f3ea277fa79f1fc727a74ef9f42ed0c3f7cab515761e0ce14f8c7d0dad65f33f1b25c71a4bfb00581e308790e7a7f92f55a5e8f63b34341f039e2b4009f4c02e6d361dc612fe7df26be208c50fc839e24f7812decbe891c8ac91fa5b0ce02ee01a59b422993731ebf3e5e72d304e6341e13e8e458449d12fff439d2b54721b6c03a013ddd25f0a9d6ab2718e96d3e3564aee745eb27406e6bcc786cbe0091c07fc0b5fa3782735168f6aaffc9f69b0d9e65eab0a8c3b0feee4a9adc4914664b649959d96d192ce4c8d7d631d6ff4853c8a59e5c9c4733ada5c1bf6f1043fd9364c12c096a05049cd7475bb6a1c8ccdec92d6bfae6f1cbaea01626254a5d51789c618977c758568718f8e396adbd2612c6975668e3ea543480e9cf0fa7a85e875169ee540ea0671ffebe8a8271b8e3d4bef80130d039d7f707dbba0dc7b161ec1dc53a49248e6a0c600a3165da57d72454ae74ba674ca0b10fc6c2a0b44ae09bd0d6e40880616b025c1a0b15a64702362f0b05e10b5152c73ce2998f4363446b609b7e1c4b9f5fe1a3f39ca40ee4ccea9eeaefb0eb714f360e3e79f2fe145a8653382d6360a434c1a28348f61379b507af045fc467f800d806aced353c918bed11779afef20d1044bd9ec6a9e6308f6867348dfc95029a714b0dc1ba8caf532ac28ab9160d5c14c882ef391d17fd9c3e58e237c4b267056e92f4d5541407baef1f1a758cbceac470c18d4acfefdc908c769ad17b1979a7bd6dd46ab7304e1e301d84ad3908bcd8059afcb36071ad5a84736965107ac02c64fe1ad686eb8dde8f143326894a000ecaf72bbb907884fc720394926417fdce2cf410c5ca1ecb1f36277e7774db916d6b897e8afb7688ab26f1a680f38fffbe4edc7a25acc51d1604e0d6eaf9859c58a714b3d1785d165185ba71b06df8d26587aa4c18f45bce358d308b7932adc16978f7dd61b6faad93c972f481e16d69879359f538893e1d114118eae2f565683e8b08fbddf875e0fee5ab23dc81a5486c0cc41f59c623f34d4ecf249995627739b3629fe5ff87d92491604f3850a8ffb459b0e16cbc2812fe76bf7dd18a18c1a32f44030e29eea84e4cb7a4137c608d876786f476619e6d3e8d76b975b8d7d455e40cdf5a6507ad99368086b9c01d087dcd623be2bfd54e62d8f629b115b6b15f06ee3f68b48150f402dbdd869d56847bdd4576015e3d7c7379d0717a27be8a52bfaa799ef3e76098a91ab8e9d8a95eadbb616e842d458e5326f5f28eaf181f4c5e43f6aa0020c48c7fbc4f94027adac11a252d5647d908e4bed1a1fc76c94ed8748c4912769df9de86f462766b2312999f5c80f136fbba5542555dbd660cf7eea7977987d33b0727a9a0c9ab3fabea78a2ef717a8d05153f1d8626fdd6b601c3fd77602eee998ac93d70d6f5448afd438c1960b96f38b774228d4ae100134ec13de4ba2ecefb583a24f333353d238a518356bd7852d2cb4be1dc5e960d4ef3793e51f6ca3da30e93414f883637b94b883fdf2c65658deb35b5411d4199d746d4af2523ce590c9869409480c4952991202d3731c164248b2c8348f38a852a14f0d552b2aee71439cad432f391550e1e0be7f4c130e1ea39df301aaeae191b9b50109ea9a530aa9a00566dff00502c5d874b81c4429b03fb79dba3f6fdd2098401275b09acde195a2598296557ff5120c0450a6ca942f25581773e319019c1281018d8995e70a445dda3425249e9315d37b5c38b2e137636e81746b15abbbbc9df0038e5fb25204206c153838f5d3ccdc81605cb90e5eefe0f1a5b20447434e3fc4bd1b6f749e254938fd4693d31dd7ccc8574890f3a466358c00a37f41fb5b9271c26fa048c7c62877d9cf04edaf82314ae95f0a54853f3d5b13e35142421cb557f94a9071fa83465b32f06f9a800b4d44886bee9257856ca82a3f2e0adc27c741a416c9d9547cebd414248d23c2aeab2df35d30a78d8fe6fa882c93c5c2964aeca6d3221e970f4f28b35fa15eb54d1e218b8c3c6589886c326dfd11af4c69d02a50143f4adfa0cfa71d19f9a6b89d0e402c79359ffc00ed37765ccf6abc1a3a3c3a2ef90d685bb65e28e59d76d42a13791184f2d5f0156d5b3e6274a9a517cdd1382376dd9381418a9c469dcb675a3ef838e31bff7d4c8306e8ab96d6f2202d93b303da9e12cccd5e30db0bd267d1dbbbdde14198a4d55c198a0d4039d96cc9cdbb8ad9e80f4a3b5bb4fa9f241777a14cd9d907807f32d8b998cfcc4b7aaabbe84da224c5e04932222e0da5e9aa1daab26c6a6266f53c8799fe121b8bb5701420c7b077d85be241b6d67ef96164260e2a27de0d8e511f3b64c5603a3507ea46b6e83a13e85e17a7c1d41a76c1f7736f001bd8e17492bd3da0420c375ae9784df36f45596f9708c90780f41fb4bbf4e35e56df624aad774ce1ab8c302ddbbe5330699da2add7c16ce7e8fe305509236dcb7c1c3246ac7ca142d26321ba5be02536e11b3edbc0d7c70851a3191ae8c0efdcca6555491ec53f7fffed6ffa88158fa0b0ad90f03be4a2d6e3f28d09168a4377b694f249f2f30510b47486ec7c291fdd0d4bb1a7b1a14b16a598af90e3534bca3f541ca496cfcceca524ede9e35d58bfafec9a1b94c5b5ac35b7cbd0888f283897392bec8c6b25d0a5c96e051b5239830351609d19f840d51b8a369cddd269b3a7389c7c0667727442c3b5903141958bb53651a6fd6f843cdeeaf4c609f37a17c6ef33b017902acb59ed12664593757f51d6321686c8780d91e6e97768670eabbbf2ea0ff5b9a7a9bcac339cf96e6667e405c9a930f6b3c139a29fa78998643b0baf760b3b107bb8df1d419b9e59eed940cc6307d1784fb2744e106c9fcc58a2218c97000c3434aa05be5f5e4714c8b24befc7dff1bf4ffec2ae37e300b494cb05e7126ba43418f59db010be12ac089ad0dd3a9343801f01f9ed371db3a242101b45dce84e0030e5467a2813626e0ddff8b8311c05f8e49dea480a683ea3891909f0ab1b83cd5fbc21e5bc0bb72f6fcae6e6d2777eb17da36d56821274965438e9b82dab7c87256427493d930caf86741fbba6a5d25731a479a66882cbc74fbf6bc12c7a57ccf12c73c7926b396f43fa26352ad005254a0fa803f7123b8497ad0cf235e4e9cfe9d9025a0ad2da64853b97830d6c67aaf3252881eedc1c98e1a1f561cd01be340799ecc43e551ba2b0491bb3b19d43bc91e4c0cb699df0434b33fd9974c6143b5fafc52c24d7bbdf40c9712fb6719040c958f12790af7dc55277406646d9451e3e7ee39f8770d22df54e275005ca52f0bcbfe18ed34ee1cc01d063e4d3508e6a7ee247b37b32016513ce12041df41263a45d0ba5ebf6a82ac0bfc04d8fb68fa0eb2db80c40101f1ae700ea96872c28402328c92ef6479aed7b5d84fa61e0919be2a63ef5caf6ff020700b312697f9004132ee5e94d2fabb8ab92e9f5aa8efc03377baec77c574720d35d24e65bf7fff60234160f1bca1fd60ced7ad8957dc52c2557e36cfcd2522e451038e2e801b9e435d7ece4ebb690b43ce8316b91d6ff6a7b5d2793c30ce0af047e997f16f3d07f1c80132f7490b1dce93d2e8cba397b3d90fb376426cd1a087548747ca10aabb06d41d42477c7d757f3a22504e605dbef988f1ace6bddfd937e1de2167ea8aa3dc0ceb767de7e8400a9cd1bec9e3a908e6d9a128cc97019cbe47339657f26ab6b6d388d3bf7846bbf213a1bb7dcc707a3bd1cd7521e21a812e12d83f0ed21e72249b343a52bbdc16057f35a1b4107d92e69e16cecb3485f0fd0ac83877735076ac8651530923fc60e4e6d01da366132d51c1932c1d30c88ac685c84442a7965e0d7ae5b2b6620771f2bccf026441af40fdd8e03933db2b2ac4a9e1db06c151ef49ac8c6a764e9dbcbd583e51c6adfcbea4a55254a24a0952a1eb296bbe5afb0e7a64193fd4ad0459f136ae4cf2cd7870553196ff010fee4ea6771e1529ba8e492a29d4fd04c2a4ff4ff4a6a11ad2b0c808ae72f231155ef2a840585e46efcf6a39af541ea66ecc01b19911c28da9c44daa7698afcff273e08f93e9adc0130a1a0d82cf704bcf7be9e6fdb29da979f3deced24d89e1ec50c3ffc8ffd2bc879cc87c296abb32a8fd00f73368955446fe958e903b440c7a83e4bb6305e7386ebdfe1a726117cedf3a8820fcee2098c5ebbdec90f72cfdc02b617975ce0b4d080c9e28a144221d7e5bdbae558d225da456c0fe3ab0b1278da1fa448f47a04b7f9dd7f5947063589c83ff46b05e7b5c8890789b92b16eefa21081290cd0ddaeb20317a4b5a3b6363e717b2a1697725fdc7f99d52e6f504f03b856144f530740f7c396efecde308f175ecf97616d264c6c188c763957b8c37acd1f83ea3279a2da15cc77b14ccaaf6c9846fdfbddeec3ebe9b028b339ac2722bf9057f5502ea6f994e793990c1b05ae1e60b01d85b62265536411f972c3dad263e4fa2d39af573c12bb8de3d5cfe0d14194668e11fa66f5c618eefcce70ecb3322e03341ca90ae27892b7181704ed5a2688aaf5995a23aed34cce041f1b4e7407709526c4ad2d5096f183fa504c27912381415773474647ee253515fb92abe61a7af72696a9e741a1f114cec15aadd02f56140c3df77ea8019cb50081a33dbeb0df8464ceb08a9c005ab33a11d6739199cc4110fbb8e5df827a83ba3863ef01374ef358a3abce5f919022106fd6936f3c35fa5666df1eced23af71a5853c2e60c8e24d3eac1343c845371cfbe7fab931781599e6b28a182161c2c8e2a0f9133b622432e4f9a1f333c839468fa5f73a30865642d477943953ac5c19b5d0e68f06c302127309c2f04e7bd0624eb0ace411e11f821f8c38606f1d181d8d7ba6662393795ac3eed23f8f1732ba1bf0d435bb8f7b9c25dc79d26d7fbc49effaaa7dffaaf868d03c40238a3d449febd440de43b8cddd8fad7747ce3bfa27c07ebf1aea65f21c419c5e2a7470fab6f92f13c8cc1ad9d13aeb3ce9141cb732309032b54c9eb46f6c8c7739467c2bc86d31c9848cfe4141284b4ee29a4a5b550f233ff74d88bed6e0fad6dec4cef534ae416958d9c806658561c5f6eb6a1d73ead10332e8e2357c1d00f60ffe4c3b84b90fe0cd942f65390f3614222b3df9b6658f08a785abefce4189772e5d48feccc6e2c390aec88596e017bd50a023def7b504fd864154ddc782802b45a17b948207c5079a9eac9a3b3fa8d4db09932af018f52cee5f6154ff7bbed93d483133602035f8b58615dac7f1f4374a3b86409715e81a35a4477b5d90cedb129dcaf7a1f14a02c935928af5d559b2407fc2fb446c1a6f423f0281d375674bcc843f197126cd607bdf90dd5b213360850f0d86b5171a2e08c3a91bcd1f7ad662af16cdaa3dea980b025d32f4be4ca9d83680be3aab6b589fee58c93ac3cba3221a8478f61d0f08fbace6043bd2d889c8bd3bf3e3ba47e452ec670c485104165ad244105f98de249edde6b4b289f67d052eceb32a5258f567c9146e902227d5f97f43861e53e69e43aabc3caad3dc73be9e3bd3a49d11d0e8fa375d693b7bcc35c73655a8118eecb35210b193dc6ad21c65d820a7f1cef07f158010c12da11b6005b7b5c17f3a8bebf26f825f98781df729442b513c879b4c4b86b48a625d1abed6160686c664aa9470426838ebe82012516a185fcb7af9bf32a420612c3160c1f5ca560bfebba66d4736f5341a5dc020ca64b24f33e8159a34aeb5a6f0d3678d896bd21e68283449fdea352f60f7670a3329f0ae5a70d4f2de36b3aedaf5922942132f90ff169f1b0efa56951f3cfbfc9273d1378c6e022123869bd231529028526d281aa7f708324ae0db8cd934103421de3936c276f42a943dc52c614c5d714a846b25002b3a9fd89338768e53940f0eecd8c5c28d9f2db232ae16b95c427bb3476e25a2db4f658867d095245ea338cdde44c7c4f7c1717951e88f9090905529564ef8807eb0e05d9b5f232241d2a01450e999bc118266ffe23032e6e2e2ba9fbb82903c5ffd9a7aa95235ca95777d6f5cab5a705691e30b809656475989305b2d594e460b96aab037005c6a7398300e242ac038f59341f2c645f081edc285cf1beda38f34906c0fb6f42effb9606576a6ffcc53794495a68bf51e516b7a958a3445fa711fa1aea18f3f8a2eda15c2da8fb4c7571cc7c167c8ac9088d776f15cd3ce539cdca1b107888060da4e662d2d6b23c915962d8d23467d7a00e9b20b9192623595b1ad29161b9c8997f747772dd70a952dde91cf5082d1a6cd6e21b3e57c90d8f45b13e57f5f412d31ab262d699e2c400317a0ef7ed1bf0ff001e7bdf4c07937cabdf8cb3e4f5bc95c801ee54f20cc66444fb305a4b7f019c3e998ca0f21a0740c08fcbef16e83ba8d361342284bd9ec504ddb558f3bec0af6bfdb61a208ffb3bf20f0f82cb9a78b0e95d6891a08b3fbfa67005ef96d3b10ac7a28c52f8ef106b47d2715ad306727aeb2f9ded4b88bdd751e0aac70f8c507b6fa53d005894a6367264e424927f5ec8a551e0cb80537d3b23a38e0ba0880f0c835aac8f7a023228c12278d70e355a8e635ceaf67c31127a8a47e0e84692ff03fc0f22b2f4116d2d9ea362bb3d5f97b689b9275017125f5b92bb33e6b3bf0784bd6aea254914166f46d68b4559153633d43ac2ec8107b6695d41d3783764f10dece4d0b5228ac39e7bd5dc8ffa7d3fcfff0cd52515c739d6f0861fb3bce175907ac374fa9b18438d3337af0d1339e6d2df9a8ab0e9a3641cec9c30a7276400a4877b808897f712b3134a6f748bce9a9f49ac0e48210abd968f1b2abcd403e95156d39c22cdb4251f8181c93d5830dd3ee3b2a0f4e8235f8bcc9b0964b1eeca8982a30cb6242b435a84236b55625af2a13a2e5861dc0d1723c0e6b4f6d3d7540f9543de9cb77c3cc7ccab3f5a0b96f5fa49da9fea9feefb6304a21e5e11acdad7d54b446794697b91fdb7d57bd062ab3e3a2dde3e4e8b51be7d7506f3f8a1780a7901cbc2feb44e3c911ebd5ab27dd146aaaa8755a02dcbcfc01177421297de22dd0f1e9002bf1074af0e35c18ff50d8e846b2aa94b53d367778c137d09c5ba02b7ad540800b3c76a6eda454b85d38ac5cffc51a7a6d9131ea9e3098ceba9422a06ae4e0c7561320852ada98d26edc473c920fee91039350199a4c32befaac68b9110da63ca53f0dca92e922398d540fac6a1d9ef32cab1b3458ad8b6c20f5c4bdd41e3b349feea5edb323fffada1b00d476e7032f10965cdab737c686c63579ce16f71d116edff777448e6ab7f94af18bbdac53cd52d944f61acc99c3b09d46d9ee3d0bd51f295c7ef3becb29ceea8e2b1b8adae4f0e03f2ac8979aa0dd37c1bec72c676c70f082041a4af0ba9ee2719fc98610d3096663ca0dd25d0c88ae844c620e0587f1d83b4efdd1e9c4d3c104e42bd19de349124c3c1ec50af732d8ecb434a508b6e8a1b0a11446f63fbb73b3ccc276d6126b26b5cfe391d3480a18af0eb6bca5fefdf9ac3df828223609f</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">c7w 2021/1/16 15:05:38 读书笔记（bushi<br/>(密码长度119个字符，暴力破解肯定没戏啦，我自己都得复制粘贴进)</span>
      </label>
    </div>
  </div>
</div>
<script src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组-入门</title>
    <url>/2020/ds-fenwick-tree-basic/</url>
    <content><![CDATA[<h2 id="Basic-Concept"><a href="#Basic-Concept" class="headerlink" title="Basic Concept"></a>Basic Concept</h2><p>树状数组可以用于高效计算数列的前缀和，区间和等等。</p>
<p>它可以支持在$O(logn)$的时间内得到任意前缀和，以及在$O(logn)$时间内支持对区间单点值的修改。空间复杂度为$O(n)$。</p>
<h3 id="数组存储方式"><a href="#数组存储方式" class="headerlink" title="数组存储方式"></a>数组存储方式</h3><p><img src="https://s3.ax1x.com/2020/12/22/rD8IfS.png" alt="rD8IfS.png"></p>
<p>如图所示。</p>
<p>$A[i]$代表原数组的元素，$C[i]$代表树状数组中的元素。</p>
<pre><code class="lang-c++">C[1]=A[1];
C[2]=A[1]+A[2];
C[3]=A[3];
C[4]=A[1]+A[2]+A[3]+A[4];
C[5]=A[5];
C[6]=A[5]+A[6];
C[7]=A[7];
C[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8];
</code></pre>
<p>而其索引的二进制表示如下：</p>
<pre><code class="lang-c++">C[1] = C[0001] = A[1];
C[2] = C[0010] = A[1]+A[2];
C[3] = C[0011] = A[3];
C[4] = C[0100] = A[1]+A[2]+A[3]+A[4];
C[5] = C[0101] = A[5];
C[6] = C[0110] = A[5]+A[6];
C[7] = C[0111] = A[7];
C[8] = C[1000] = A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8];
</code></pre>
<p>我们可以找出规律，</p>
<script type="math/tex; mode=display">
C[i] =\sum_{k=把i二进制表示的最低位1置为0后，将新的值+1}^i A[k]</script><p>也就是说，问题在于如何找出$i$的最低位$1$所代表的数值。</p>
<h3 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h3><p>这里我们可以引入<code>lowbit</code>函数。</p>
<pre><code class="lang-c++">int lowbit (int x)
&#123;
    return x &amp; (-x);
&#125;
</code></pre>
<p>我们已经知道，对于整数表示，有</p>
<ul>
<li><p>正数的补码是其本身；</p>
</li>
<li><p>负数的补码是在反码的基础上$+1$；</p>
</li>
</ul>
<p>因此<code>x &amp; (-x)</code>就可以满足我们对于查找最低位$1$的需求。</p>
<p>举个例子：</p>
<ul>
<li>二进制数 $11010$ (1) </li>
<li><p>其反码为 $00101$ (2)</p>
</li>
<li><p>加 $1$ 后为 $00110$ (3)</p>
</li>
<li>将(1)(3)两者相与便得到最低位的 $1$ 所表示的数值</li>
</ul>
<h2 id="树状数组的建立"><a href="#树状数组的建立" class="headerlink" title="树状数组的建立"></a>树状数组的建立</h2><p>上面准备工作都做好了，码就行了:(</p>
<pre><code class="lang-c++">#include &lt;iostream&gt;
#define MAXN 12
using namespace std;

int ft[MAXN+1] = &#123;0&#125;;
int a[MAXN + 1] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12&#125;;

int lowbit(int x)&#123;
    return x &amp; (-x);
&#125;

void generateTree()&#123;
    for (int i = 1; i &lt;= MAXN; i++)&#123;
        for (int k = i - lowbit(i) + 1; k &lt;= i; k++)
            ft[i] += a[k];
    &#125;
&#125;

int main()&#123;
    generateTree();
    return 0;
&#125;
</code></pre>
<h2 id="单点更新"><a href="#单点更新" class="headerlink" title="单点更新"></a>单点更新</h2><p>再把这张图拿过来：</p>
<p><img src="https://s3.ax1x.com/2020/12/22/rD8IfS.png" alt="rD8IfS.png"></p>
<p>如果我们要更改$A[3]$的值，那么我们知道，$C[3], C[4], C[8]$ 的值都会受到影响。</p>
<ul>
<li>$3(011)$ =&gt; <code>C[3] += temp;</code></li>
<li>$lowbit(3) = 001$, $3 + lowbit(3)= 100 = 4(100)$ =&gt; <code>C[4] += temp;</code></li>
<li>$lowbit(4) = 100$, $4+lowbit(4)=1000=8(1000)$ =&gt; <code>C[8] += temp;</code></li>
<li>……</li>
</ul>
<p>因此，我们只需要对所要更新的数据不断使其自增lowbit后，</p>
<p>使树状数组的对应索引增加 temp 值即可。</p>
<pre><code class="lang-c++">void update(int index, int val)&#123;
    for (int i = index; i &lt;= MAXN; i = i + lowbit(i))&#123;
        ft[i] += val;
    &#125;
&#125;
</code></pre>
<h2 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h2><p>假设现在我们要查询1~7的前缀和。</p>
<pre><code class="lang-c++">C[7] = C[0111] = A[7];
C[6] = C[0110] = A[5] + A[6];
C[4] = C[0100] = A[1] + A[2] + A[3] + A[4];
</code></pre>
<p>归纳可知，我们只需每次将索引减少i的lowbit，然后将对应的树状数组的值求和即可。</p>
<pre><code class="lang-c++">int getSum(int index)&#123;
    int result = 0;
    for (int k = index; k &gt; 0; k-=lowbit(k))&#123;
        result += ft[k];
    &#125;
    return result;
&#125;
</code></pre>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84">https://zh.wikipedia.org/wiki/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84</a>‘</li>
<li><a href="https://bestsort.cn/2019/04/26/195/">https://bestsort.cn/2019/04/26/195/</a></li>
</ul>
]]></content>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划的背包问题</title>
    <url>/2020/dp-backpack/</url>
    <content><![CDATA[<p>所以为什么要找一个背包图片当头图啊喂</p>
<h2 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0/1 背包问题"></a>0/1 背包问题</h2><p>有$N$件物品和一个容量为$V$的背包。<strong>每种物品仅有一件，可以选择放或不放。</strong>第$i$件物品的费用是$w[i]$，价值是$c[i]$。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 </p>
<p>设$f[i][v]$表示前$i$件物品(部分或全部)<em>恰</em>放入一个容量为$v$的背包可以获得的最大价值。则其状态转移方程便是：</p>
<script type="math/tex; mode=display">
f[i][v]=\max(f[i-1][v],f[i-1][v-w[i]]+c[i])</script><h3 id="0-1背包的空间优化"><a href="#0-1背包的空间优化" class="headerlink" title="0/1背包的空间优化"></a>0/1背包的空间优化</h3><p>我们可以将二维数组存储优化为一维数组存储。</p>
<p>在每次主循环中，如果我们以$v=V…0$的逆序推$f[v]$，这样就能保证推$f[v]$时$f[v-w[i]]$保存的是状态$f[i-1][v-w[i]]$的值。</p>
<p>伪代码如下：</p>
<pre><code class="lang-c++">for i = 1...N 
    for v = V...0 
        f[v] = max(f[v], f[v-w[i]]+c[i]);
</code></pre>
<p>　　其中$f[v]=max(f[v],f[v-w[i]]+c[i])$便与原转移方程等价。</p>
<h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><p>有$N$种物品和一个容量为$V$的背包，<strong>每种物品都有无限件可用</strong>。第$i$种物品的费用是$w[i]$，价值是$c[i]$。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 </p>
<p>令$f[i][v]$表示前$i$种物品<em>恰</em>放入一个容量为$v$的背包的最大价值，于是可以按照每种物品不同的策略写出状态转移方程：</p>
<script type="math/tex; mode=display">
for \ k\ in \ range[0, floor(\frac v {w[i]})]:\\
 f[i][v]=max(f[i-1][v-k*w[i]]+k*c[i])</script><h3 id="完全背包问题的空间优化"><a href="#完全背包问题的空间优化" class="headerlink" title="完全背包问题的空间优化"></a>完全背包问题的空间优化</h3><p>完全背包的特点恰是每种物品可选无限件，所以我们可以考虑“加选一件第$i$种物品”策略。因此我们可以使用<strong>可能已选入第i种物品</strong>的子结果$f[i][v-w[i]]$，于是我们必须采用$v=0…V$的顺序循环。</p>
<p>伪代码如下：</p>
<pre><code class="lang-c++">for i = 1...N 
    for v = 0...V
        f[v] = max(f[v], f[v-w[i]]+c[i]);
</code></pre>
<h3 id="另一种解法：转化为0-1背包问题"><a href="#另一种解法：转化为0-1背包问题" class="headerlink" title="另一种解法：转化为0/1背包问题"></a>另一种解法：转化为0/1背包问题</h3><p>考虑到第$i$种物品最多选$floor(\frac V {w[i]})$件，于是可以把第$i$种物品转化为$floor(\frac V {w[i]})$件费用及价值均不变的物品，然后求解这个0/1背包问题。</p>
<p>更高效的转化方法是：把第$i$种物品拆成费用为$2^kw[i]$、价值为$2^kc[i]$的若干件物品，其中$k$满足$2^kw[i]&lt;V$。这是二进制的思想，因为不管最优策略选几件第$i$种物品，总可以表示成若干个$2^k$件物品的和。</p>
<h2 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h2><p>有$N$种物品和一个容量为$V$的背包。<strong>第$i$种物品最多有$n[i]$件可用</strong>，每件费用是$w[i]$，价值是$c[i]$。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p>
<p>基本的方程只需将完全背包问题的方程略微一改即可，因为对于第$i$种物品有$n[i]+1$种策略：取$0$件，取$1$件……取$n[i]$件。令$f[i][v]$表示前$i$种物品恰放入一个容量为$v$的背包的最大价值，则：</p>
<script type="math/tex; mode=display">
for \ k\ in \ range[0, n[i]]:\\
f[i][v]=max(f[i-1][v-k*w[i]]+ k*c[i])</script><p>循环时注意$v-k*w[i]$ 非负即可。</p>
<h3 id="转化为0-1背包问题"><a href="#转化为0-1背包问题" class="headerlink" title="转化为0/1背包问题"></a>转化为0/1背包问题</h3><p>将第$i$种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为</p>
<script type="math/tex; mode=display">
1,2,4,...,2^{k-1},n[i]-2^k+1</script><p>且k是满足$n[i]-2^k+1&gt;0$的最大整数。</p>
<p>例如，如果$n[i]$为$13$，就将这种物品分成系数分别为$1,2,4,6$的四件物品。 </p>
<h2 id="二维背包问题"><a href="#二维背包问题" class="headerlink" title="二维背包问题"></a>二维背包问题</h2><p>二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。</p>
<p>设这两种代价分别为代价1和代价2，第$i$件物品所需的两种代价分别为$a[i]$和$b[i]$。两种代价可付出的最大值（两种背包容量）分别为$V$和$U$。物品的价值为$c[i]$。</p>
<p>费用加了一维，只需状态也加一维即可。设$f[i][v][u]$表示前$i$件物品付出两种代价分别恰为$v$和$u$时可获得的最大价值。状态转移方程就是：</p>
<script type="math/tex; mode=display">
f[i][v][u]=max(f[i-1][v][u], f[i-1][v-a[i]][u-b[i]]+c[i])</script><p>如前述方法，可以只使用二维的数组：当每件物品只可以取一次时变量$v$和$u$采用逆序的循环，当物品有如完全背包问题时采用顺序的循环。当物品有如多重背包问题时拆分物品。</p>
<h3 id="物品总个数的限制"><a href="#物品总个数的限制" class="headerlink" title="物品总个数的限制"></a>物品总个数的限制</h3><p>有时，“二维费用”的条件是以这样一种隐含的方式给出的：最多只能取$M$件物品。这事实上相当于每件物品多了一种“件数”的费用，每个物品的件数费用均为$1$，可以付出的最大件数费用为$M$。</p>
<h2 id="咕咕咕"><a href="#咕咕咕" class="headerlink" title="咕咕咕"></a>咕咕咕</h2><p>还有分组背包还有依赖背包但懒得写，源代码也有空再说8</p>
<p>诶mathjax怎么又炸了</p>
<h2 id="Practice"><a href="#Practice" class="headerlink" title="Practice"></a>Practice</h2><ul>
<li><a href="https://www.luogu.com.cn/problem/P1833">https://www.luogu.com.cn/problem/P1833</a></li>
</ul>
<p>附AC代码：</p>
<pre><code class="lang-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;

int v, n=0;
    //  i j   k
int f[1001] = &#123;0&#125;;

int max(int a, int b)&#123;
    return a &gt; b ? a : b;
&#125;

void processTime()&#123;
    int a, b, c, d;
    scanf(&quot;%d:%d %d:%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d);
    v = d - b + (c - a) * 60;
&#125;

void tryItem(int cost, int value, bool inf)&#123;
    if(inf)&#123;
        for (int j = cost; j &lt;= v; j++)&#123;
            f[j] = max(f[j], f[j - cost]+value);
        &#125;
    &#125;else&#123;
        for (int j = v; j &gt;= cost; j--)&#123;
            f[j] = max(f[j], f[j - cost]+value);
        &#125;
    &#125;
&#125;

void decompose(int cost, int value, int num)&#123;
    int base = 1;
    while(num&gt;=base)&#123;
        tryItem(cost * base, value * base, false);
        num -= base;
        base &lt;&lt;= 1;
    &#125;
    if(num&gt;0)&#123;
        tryItem(cost * num, value * num, false);
    &#125;
&#125;

int main()&#123;
    processTime();
    int n;
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++)&#123;
        int a, b, c;
        scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c);
        if(c==0)&#123;
            tryItem(a, b, true);
        &#125;else if(c==1)&#123;
            tryItem(a, b, false);
        &#125;else&#123;
            decompose(a, b, c);
        &#125;
    &#125;
    int result = 0;
    for (int i = 1; i &lt;= v; i++)&#123;
        result = max(result, f[i]);
    &#125;
    cout &lt;&lt; result;
    return 0;
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>dp</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-堆</title>
    <url>/2020/ds-heap/</url>
    <content><![CDATA[<p>　　　数据结构中的堆结构　　　</p>
<h2 id="Knowledge-Base"><a href="#Knowledge-Base" class="headerlink" title="Knowledge Base"></a>Knowledge Base</h2><ul>
<li>完全二叉树：</li>
</ul>
<p>​        如果一棵深度为 $k$ 的二叉树，$1$ 至$ k-1$ 层的结点都是满的，即满足 $2^i-1$，只有最下面的一层的结点数小于$2^i-1$，并且最下面一层的结点都集中在该层最左边的若干位置，则此二叉树称为完全二叉树。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>​        堆结构是一种数组对象，它可以被视为一棵完全二叉树。树中每个结点与数组中存放该结点中值的那个元素相对应，如下图：</p>
<p><a href="https://imgchr.com/i/Da1oSH"><img src="https://s3.ax1x.com/2020/11/25/Da1oSH.png" alt="Da1oSH.png"></a></p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul>
<li><p>下标：</p>
<p>​    第$i$个结点的父结点（parent(i)）、左结点(left(i))、右结点(right(i))的下标分别为：$\frac {i}{2}$、$2i$、$2i+1$；</p>
</li>
<li><p>大小：</p>
<p>堆可以分为<strong>最大堆(max-heap)</strong>和<strong>最小堆(min-heap)</strong>两种，分别满足对于任意的$i$, $A[parent(i)] &gt;(&lt;)A[i]$.</p>
</li>
</ul>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ul>
<li><a href="http://www.cplusplus.com/reference/algorithm/make_heap/">make_heap</a></li>
<li><a href="http://www.cplusplus.com/reference/algorithm/push_heap/">push_heap</a></li>
<li><a href="http://www.cplusplus.com/reference/algorithm/pop_heap/">pop_heap</a></li>
</ul>
<h2 id="src"><a href="#src" class="headerlink" title="src"></a>src</h2><pre><code class="lang-c++">//最小堆
class smallHeap &#123;
public:
    int size, maxSize, * head = NULL;

    void init(int depth) &#123;
        int p = qpow(2, depth, 19260817);
        head = new int[p-1];
        maxSize = p - 1;
    &#125;

    smallHeap(int depth) &#123;
        init(depth);
    &#125;

    int getSize() &#123;
        return size;
    &#125;

    bool put(int val) &#123;
        if (size == maxSize) return false;
        size++;
        int currentNode = size; head[currentNode] = val;
        while (currentNode != 1) &#123;
            int parentNode = currentNode / 2;
            if (head[parentNode] &gt; head[currentNode]) &#123;
                int temp = head[parentNode];
                head[parentNode] = head[currentNode];
                head[currentNode] = temp;
                currentNode = parentNode;
            &#125;
            else &#123;
                break;
            &#125;
        &#125;
        return true;
    &#125;

    int get() &#123;
        int currentNode = 1;
        int tempValue = head[currentNode];
        head[currentNode] = head[size];
        size--;
        int parentNode = 1;
        while (1) &#123;
            if (parentNode * 2 &gt; size) break;
            currentNode = (head[parentNode * 2] &lt; head[parentNode * 2 + 1]) ? (parentNode * 2) : (parentNode * 2 + 1);
            if (head[parentNode] &gt; head[currentNode]) &#123;
                int temp = head[parentNode];
                head[parentNode] = head[currentNode];
                head[currentNode] = temp;
                parentNode = currentNode;
            &#125;
            else &#123;
                break;
            &#125;
        &#125;

        return tempValue;
    &#125;

    int top() &#123; return head[1]; &#125;

    void show() &#123;
        for (int i = 1; i &lt;= size; i++) &#123;
            cout &lt;&lt; head[i] &lt;&lt; &quot; &quot;;
        &#125;
    &#125;
&#125;;

//最大堆
class bigHeap &#123;
public:
    int size, maxSize, * head = NULL;

    void init(int depth) &#123;
        int p = qpow(2, depth, 19260817);
        head = new int[p-1];
        maxSize = p - 1;
    &#125;

    bigHeap(int depth) &#123;
        init(depth);
    &#125;

    int getSize() &#123;
        return size;
    &#125;

    bool put(int val) &#123;
        if (size == maxSize) return false;
        size++;
        int currentNode = size; head[currentNode] = val;
        while (currentNode != 1) &#123;
            int parentNode = currentNode / 2;
            if (head[parentNode] &lt; head[currentNode]) &#123;
                int temp = head[parentNode];
                head[parentNode] = head[currentNode];
                head[currentNode] = temp;
                currentNode = parentNode;
            &#125;
            else &#123;
                break;
            &#125;
        &#125;
        return true;
    &#125;

    int get() &#123;
        int currentNode = 1;
        int tempValue = head[currentNode];
        head[currentNode] = head[size];
        size--;
        int parentNode = 1;
        while (1) &#123;
            if (parentNode * 2 &gt; size) break;
            currentNode = (head[parentNode * 2] &gt; head[parentNode * 2 + 1]) ? (parentNode * 2) : (parentNode * 2 + 1);
            if (head[parentNode] &lt; head[currentNode]) &#123;
                int temp = head[parentNode];
                head[parentNode] = head[currentNode];
                head[currentNode] = temp;
                parentNode = currentNode;
            &#125;
            else &#123;
                break;
            &#125;
        &#125;

        return tempValue;
    &#125;

    int top() &#123; return head[1]; &#125;

    void show() &#123;
        for (int i = 1; i &lt;= size; i++) &#123;
            cout &lt;&lt; head[i] &lt;&lt; &quot; &quot;;
        &#125;
    &#125;
&#125;;
</code></pre>
<h2 id="Practice"><a href="#Practice" class="headerlink" title="Practice"></a>Practice</h2><ul>
<li><a href="https://www.luogu.com.cn/problem/P1090">https://www.luogu.com.cn/problem/P1090</a></li>
<li><a href="https://www.luogu.com.cn/problem/P1168">https://www.luogu.com.cn/problem/P1168</a></li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://github.com/raywenderlich/swift-algorithm-club/tree/master/Heap">https://github.com/raywenderlich/swift-algorithm-club/tree/master/Heap</a></li>
<li><a href="http://www.cplusplus.com/reference/algorithm/">http://www.cplusplus.com/reference/algorithm/</a></li>
</ul>
]]></content>
      <tags>
        <tag>Data Structure</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>一些参数方程/极坐标图像</title>
    <url>/2020/figure-of-some-curves/</url>
    <content><![CDATA[<p>菜鸡没学过4-4，在微积分应用里面积面积和体积的时候有的草图画不出来…</p>
<h2 id="星形线"><a href="#星形线" class="headerlink" title="星形线"></a>星形线</h2><script type="math/tex; mode=display">
x^{\frac 2 3}+y^{\frac 2 3}=a^{\frac 2 3} \\
\begin{cases}
x=a\cos^3t\\
y=a\sin^3t
\end{cases}</script><p><img src="https://s3.ax1x.com/2020/12/26/r4AL8K.png" alt=""></p>
<h2 id="摆线"><a href="#摆线" class="headerlink" title="摆线"></a>摆线</h2><script type="math/tex; mode=display">
\begin {cases}
x= a(t-\sin t)\\
y=a(1-\cos t)
\end {cases}</script><p><img src="https://s3.ax1x.com/2020/12/26/r4E12T.png" alt=""></p>
<p>图为$-4\pi \le t \le 4\pi, a=1$的图像.</p>
<p>周期为$2\pi$.</p>
<h2 id="双纽线"><a href="#双纽线" class="headerlink" title="双纽线"></a>双纽线</h2><p><a href="https://imgchr.com/i/r4VeSK"><img src="https://s3.ax1x.com/2020/12/26/r4VeSK.png" alt="r4VeSK.png"></a></p>
<h2 id="笛卡尔心形线"><a href="#笛卡尔心形线" class="headerlink" title="笛卡尔心形线"></a>笛卡尔心形线</h2><p><a href="https://imgchr.com/i/r4ZSht"><img src="https://s3.ax1x.com/2020/12/26/r4ZSht.png" alt="r4ZSht.png"></a></p>
<h2 id="其它曲线"><a href="#其它曲线" class="headerlink" title="其它曲线"></a>其它曲线</h2><p><a href="https://imgchr.com/i/r4ZeNn"><img src="https://s3.ax1x.com/2020/12/26/r4ZeNn.png" alt="r4ZeNn.png"></a></p>
<p><a href="https://imgchr.com/i/r4Zu90"><img src="https://s3.ax1x.com/2020/12/26/r4Zu90.png" alt="r4Zu90.png"></a></p>
<p><a href="https://imgchr.com/i/r4ZK3V"><img src="https://s3.ax1x.com/2020/12/26/r4ZK3V.png" alt="r4ZK3V.png"></a></p>
<p><a href="https://imgchr.com/i/r4ZMcT"><img src="https://s3.ax1x.com/2020/12/26/r4ZMcT.png" alt="r4ZMcT.png"></a></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://mm.edrawsoft.cn/template/65439">https://mm.edrawsoft.cn/template/65439</a></li>
<li>部分图像采用 GeoGebra 绘制</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>密码保护文章测试</title>
    <url>/2021/encrypt-test/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="【■■■ - 密码错误 - ■■■】" data-whm="Oh, these decrypted content cannot be verified, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="8712cc481fc34ae6d16ea47f63532ef2acc2c124b33fb3f40c54973de3857f5f">018a63061e17dd91a60e05280129f742932d41a23e2bd96bdb1d48a7faba3ed7b029007f6e466b7ae950fd3977006312fab6bc5ff0c39b2e1bf6c5f37584a15703aba8c89474cb7ce75d3218d2a7d448</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Please complete the sentence: c7w,_______.<br/> You should type in four characters in lowercase.</span>
      </label>
    </div>
  </div>
</div>
<script src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>Gone with the Wind 读后随便写写（不推荐点进来看，因为我自己也看不懂）</title>
    <url>/2021/gone-with-the-wind-report/</url>
    <content><![CDATA[<blockquote>
<p>I Won’t think it now. I can’t stand it. I’ll think of it tomorrow.<br>After all, tomorrow is another day.</p>
</blockquote>
<h2 id="写这么一大堆东西谁愿意看啊，我自己都不愿意看啊kora！"><a href="#写这么一大堆东西谁愿意看啊，我自己都不愿意看啊kora！" class="headerlink" title="写这么一大堆东西谁愿意看啊，我自己都不愿意看啊kora！"></a>写这么一大堆东西谁愿意看啊，我自己都不愿意看啊kora！</h2><p>Set in the background of <strong>American Civil War</strong> and the <strong>Reconstruction Era</strong>, the novel <strong>Gone with the Wind</strong>, shows the look of the society in Atlanta, Georgia during the time. It depicts the plantation-daughter, <strong>Scarlett O’Hara</strong>‘s twelve years of struggling life to survive and get out of her poverty.</p>
<p>The title “Gone with the Wind”, which was taken from a poem, appears in the monologue when Scarlett was on her way escaping from Atlanta to Tara, desperate to avoid the Yankees and flames of war.</p>
<blockquote>
<p>Was Tara still standing? Or was Tara also gone with the wind which had swept through Georgia?</p>
</blockquote>
<p>It is no doubt that, it is the strong character Scarlett has that attributes to her uncommon life. Unless the war broke out, she might have remained the spoiled daughter of Gerald, with her thoughts completely on her beautiful appearance, her countless beaus and, Ashley Wilkes. However, to survive while the war was going on, she had to completely give up her elaborate manners. Sorrow, hunger, poverty had rebuilt her.</p>
<blockquote>
<p>Somewhere, on the long road that wound through those four years, the girl with her sachet and dancing slippers had slipped away and there was left a woman with sharp green eyes, who counted pennies and turned her hands to many menial tasks, a woman to whom nothing was left from the wreckage except the indestructible red earth on which she stood. </p>
</blockquote>
<p>As the story shows itself to us, Scarlett is trying her best to seek her true self. Through the changes of her relationships with other three main characters we can see that:</p>
<p>First, Ashley Wilkes. As a child, she couldn’t move her eyes out of him. She had tried her best to win Ashley’s affections, but all her efforts was paid in vain. It is his marriage to Melanie that made her furious and decided to marry poor Charles as a revenge. And, as time went by, her love for Ashley has gradually become her spirit support. After their conversation in Tara, she knew that Ashley and she come from different worlds, and thus have different opinions toward life. After the war, what she wanted to do was reviving the plantation, feeding the whole family and getting out of poverty. However, Ashley was always trying to get back at his good old days, dreaming for the past that has already “gone with the wind”. Ashley did love her, but it was only for her mind, her soul, and her nobility of character. Finally, after the death of Melly, she realized that all love she had for Ashley was just based on her imagination and no more than that.</p>
<blockquote>
<p>“Life’s under no obligation to give us what we expect.<br>We take what we get and are thankful it’s no worse than it is.”</p>
<p>From Ashley</p>
</blockquote>
<p>Then, Melanie. At first all the feelings Scarlett held for this lady is despisement and she was jealous of her marrying Ashley. But when Atlanta was under siege, Scarlett had to care for her and, as she thought, that was just because her promise to Ashley. But when they were in Tara, comradeship developed between them. Not only from fighting together against the Yankee-thief or putting out the fire together, but they treasured each other’s companion, at least Melly treasured and loved Scarlett. During the Reconstruction Era, Melly just tried her best to defend Scarlett’s reputation and always stood by her side. And, at last, Scarlett finally realized Melanie was one of her spirit support, but, it was too late.</p>
<p>At last, it is Rhett Butlet. Scoundrel as he is, he has always loved Scarlett, and always ready to lend a hand when she needed help. He tried his best to get Scarlett out of Atlanta during the siege, and he immediately went for her after he got out of the jail. And, he treasured little Bonnie as if she was the childlike little Scarlett. But after Bonnie’s death, he got upset and disappointed. On the other hand, Scarlett gradually saw through the mist in her heart and discovered her true love for Rhett in the end. But, but, it was too late, either.</p>
<p>At the end of the novel, Scarlett decided to get back to Tara, her plantation, to start her new life. Whether it’s because her Irish-blood or her life experience, she was fond of the red clay land, and she was fond of the farm. Just as she thinks, “she knows she could get Rhett back. There isn’t a man who she cannot get, once she has set her mind upon him.” And after all, tomorrow is another day.</p>
<hr>
<p>唔呣，可以做一篇短文改错了，好耶</p>
]]></content>
  </entry>
  <entry>
    <title>Hash Table（散列表）</title>
    <url>/2020/hash-table/</url>
    <content><![CDATA[<p>　　散列表的相关概念和内容　　</p>
<p>​        <strong>散列表</strong>（<strong>Hash table</strong>，也叫<strong>哈希表</strong>），是根据键（Key）而直接访问在内存储存位置的数据结构。</p>
<p>​        也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。</p>
<p>​        这个映射函数称做<strong>散列函数</strong>，存放记录的数组称做<strong>散列表</strong>。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>关键字为$k$的值存储在$f(k)$的存储位置中，称映射$f$为散列函数，按照这个思想建立的表称为<strong>散列表</strong>。</li>
<li>对不同的关键字可能得到同一散列地址，即$k_1 \neq k_2$，而$f(k_1) = f(k_2)$，这种现象称为<strong>冲突</strong>（Collision）。具有相同函数值的关键字对该散列函数来说称做<strong>同义词</strong>。</li>
<li>若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为<strong>均匀散列函数</strong>，这就使关键字经过散列函数得到一个“随机的地址”，从而减少冲突。</li>
</ul>
<h2 id="构造散列函数的方法"><a href="#构造散列函数的方法" class="headerlink" title="构造散列函数的方法"></a>构造散列函数的方法</h2><p>​        若采用求余的方法，采用质数可以在一定程度上解决冲突问题。</p>
<h2 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h2><ul>
<li>开放定址法</li>
<li>避免聚集：<ul>
<li>单独链表法</li>
<li>再散列</li>
</ul>
</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><p><a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8">https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8</a></p>
</li>
<li><p><a href="https://blog.csdn.net/zmxiangde_88/article/details/8025541">https://blog.csdn.net/zmxiangde_88/article/details/8025541</a></p>
</li>
<li>Computer Science: An Overview, § 9.5 Traditional File Structures.</li>
</ul>
]]></content>
      <tags>
        <tag>Data Structure</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title>同余 逆元 费马小定理</title>
    <url>/2020/inverse-element/</url>
    <content><![CDATA[<p>　　　如果会数学就好了　　　　</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>菜鸡不会打【<a href="https://www.luogu.com.cn/problem/P7108?contestId=13515">P7108</a>】，来补数学知识</p>
<h2 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h2><p>​        给定一个正整数$m$，如果两个整数$a$和$b$满足$a-b$能够被$m$整除，即$(a-b)/m$得到一个整数，那么就称整数$a$与$b$对模$m$同余，记作<script type="math/tex">a≡b(mod m)</script>。</p>
<p>​        对模$m$同余是整数的一个<strong>等价关系</strong>。</p>
<h2 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h2><p>​        如果$p$是一个质数，而整数$a$不是$p$的倍数，则有<script type="math/tex">a^{p-1}≡1（mod p）</script>。</p>
<h2 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h2><script type="math/tex; mode=display">
1\%p=a^{p-1}\%p \\
=> \frac 1 a \% p = a^{p-2}\%p</script><p>​        因此，在计算$\frac{b^h-1}{b-1}$时，我们可以将其转化成$(b^h-1)*inverse(b-1)$计算。</p>
<h2 id="最后有用的代码"><a href="#最后有用的代码" class="headerlink" title="最后有用的代码"></a>最后有用的代码</h2><pre><code class="lang-c++">long long invEl(int x)
&#123;
    return qpow(x, M - 2, M);
&#125;
</code></pre>
<p>【黑人问号脸.jpeg】</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://www.cnblogs.com/kongbursi-2292702937/p/10582258.html">https://www.cnblogs.com/kongbursi-2292702937/p/10582258.html</a></li>
<li><a href="https://baike.baidu.com/item/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/4776158?fr=aladdin">https://baike.baidu.com/item/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/4776158?fr=aladdin</a></li>
</ul>
]]></content>
      <tags>
        <tag>数学</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P1908 求逆序对</title>
    <url>/2020/luogu-P1908/</url>
    <content><![CDATA[<h2 id="归并排序求逆序对数目"><a href="#归并排序求逆序对数目" class="headerlink" title="归并排序求逆序对数目"></a>归并排序求逆序对数目</h2><pre><code class="lang-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;

unsigned long long result = 0;
int a[500001] = &#123;0&#125;;
int cache[500001] = &#123;0&#125;;

void sort(int l, int r)&#123;
    if (r &lt;= l) return;
    if(r-l==1)&#123;
        if(a[l]&gt;a[r])&#123;
            int temp = a[l];
            a[l] = a[r];
            a[r] = temp;
            result++;
        &#125;
        return;
    &#125;
    int mid = (l + r) / 2;
    //[l, mid] &amp;&amp; [mid+1, r]
    sort(l, mid);
    sort(mid + 1, r);
    int len = r - l + 1;
    int x = l, y = mid + 1;
    int pos = 0;
    while(x&lt;=mid &amp;&amp; y&lt;=r)&#123;
        while (x &lt;= mid &amp;&amp; y &lt;= r &amp;&amp; a[x] &lt;= a[y]) &#123;
            pos++;
            cache[pos] = a[x];
            x++;
        &#125;
        if (x &lt;= mid &amp;&amp; y &lt;= r &amp;&amp; a[x] &gt; a[y])&#123;
            pos++;
            cache[pos] = a[y];
            y++;
            result += mid-x+1;
        &#125; 
        if(x&gt;mid)&#123;
            while(y&lt;=r)&#123;
                pos++;
                cache[pos] = a[y];
                y++;
            &#125;
            break;
        &#125;
        if(y&gt;r)&#123;
            while (x&lt;=mid) &#123;
                pos++;
                cache[pos] = a[x];
                x++;
            &#125;
            break;
        &#125;
    &#125;
    for (int i = l; i &lt;= r; i++)&#123;
        a[i] = cache[i - l + 1];
    &#125;
&#125;

int main()&#123;
    int n;
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++)&#123;
        scanf(&quot;%d&quot;, &amp;a[i]);
    &#125;
    sort(1, n);
    cout &lt;&lt; result;
    return 0;
&#125;
</code></pre>
<h2 id="树状数组-离散化求逆序对数目"><a href="#树状数组-离散化求逆序对数目" class="headerlink" title="树状数组+离散化求逆序对数目"></a>树状数组+离散化求逆序对数目</h2><pre><code class="lang-c++">#include &lt;iostream&gt;
#define MAXN 500001
using namespace std;

int n;
unsigned long long result = 0;
int a[MAXN] = &#123;0&#125;;
int ft[MAXN + 1] = &#123;0&#125;;

int lowbit(int x) &#123;
    return x &amp; (-x);
&#125;

void update(int index, int val) &#123;
    for (int i = index; i &lt;= n; i = i + lowbit(i)) &#123;
        ft[i] += val;
    &#125;
&#125;

int getSum(int index) &#123;
    int result = 0;
    for (int k = index; k &gt; 0; k -= lowbit(k)) &#123;
        result += ft[k];
    &#125;
    return result;
&#125;

class entry &#123;
    public:
     int id, val, rank;
&#125; m[500001];

// Last Update: 2020-12-30
/* Quick Sort With CMP Start */
// Sort the element between [a+left, a+right)
// You need to implement the &quot;compare&quot; function.
// You&#39;d better implement a strict inequality in the set.
// An example is given in pseudocode.
/*
bool compare(T A, T B)&#123;
    if(A precedes B)&#123;
        return true;
    &#125;else&#123;
        return false;
    &#125;
&#125;
*/
template &lt;class T&gt;
void quickSort(T* a, int left, int right, bool (*cmp)(T, T)) &#123;
    T pivot = *(a + right - 1);
    int l = left, r = right - 1;
    while (l &lt; r) &#123;
        while (l &lt; r &amp;&amp; !cmp(pivot, a[l])) &#123;  // a[l] &gt;= pivot then continue
            l++;
        &#125;
        while (l &lt; r &amp;&amp; !cmp(a[r], pivot)) &#123;  // a[r] &lt;= pivot then continue
            r--;
        &#125;
        if (l != r) &#123;
            T temp = a[l];
            a[l] = a[r];
            a[r] = temp;
        &#125; else &#123;
            a[right - 1] = a[l];
            a[l] = pivot;
            quickSort(a, left, l, cmp);
            quickSort(a, l + 1, right, cmp);
        &#125;
    &#125;
&#125;
/* Quick Sort With CMP End */

bool compare1(entry a, entry b)&#123;
    if (a.val &lt; b.val) return true;
    if (a.val &gt; b.val) return false;
    if (a.id &lt; b.id) return true;
    return false;
&#125;

bool compare2(entry a, entry b)&#123;
    if (a.id &lt; b.id) return true;
    return false;
&#125;



int main()&#123;
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++)&#123;
        cin &gt;&gt; a[i];
        m[i].id = i;
        m[i].val = a[i]; 
    &#125;
    quickSort(m, 1, n + 1, compare1);
    for (int i = 1; i &lt;= n; i++)&#123;
        m[i].rank = i;
    &#125;
    quickSort(m, 1, n + 1, compare2);
    for (int i = n; i &gt;= 1; i--) &#123;
        update(m[i].rank, 1);
        result = result + getSum(m[i].rank - 1);
    &#125;
    cout &lt;&lt; result;
    return 0;
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>code</tag>
        <tag>luogu</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello, World.</title>
    <url>/2020/hello-world/</url>
    <content><![CDATA[<p>没钱结款只得把自己博客搬家的屑</p>
<h2 id="c7w-的破站-ver-2-0"><a href="#c7w-的破站-ver-2-0" class="headerlink" title="c7w 的破站 ver 2.0"></a>c7w 的破站 ver 2.0</h2><p>​        之前用 WordPress 搭的小站快要到期了，现在也不好找免费的虚拟主机薅羊毛，遂借用 github.io + Hexo 搭建本“静态博客”，来记录今后的点滴。</p>
<p><s>         azaz，我打点滴第一候选项是垫底，bksw</s></p>
<p>​        然后强行安利了贵班的文艺委员也用上了这种方法建的博客，甚至还组建了班级的github organisation.</p>
<p>​    等有空了就写博文，咕咕咕</p>
]]></content>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>合同矩阵与相似矩阵</title>
    <url>/2020/matrix-congruence-and-similarity/</url>
    <content><![CDATA[<h2 id="合同矩阵"><a href="#合同矩阵" class="headerlink" title="合同矩阵"></a>合同矩阵</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>称两矩阵$A,B$合同，当且仅当存在可逆矩阵$C$，使得</p>
<script type="math/tex; mode=display">
A=C^TBC</script><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol>
<li>合同关系是等价关系.</li>
</ol>
<ul>
<li>自反性: $A$与$A$本身合同</li>
<li>对称性: $A$合同于$B$, 则$B$合同于$A$</li>
<li>传递性: $A$合同于$B$, $B$合同于$C$, 则$A$合同于$C$.</li>
</ul>
<ol>
<li>合同矩阵的<strong>秩</strong>相同。</li>
</ol>
<h2 id="相似矩阵"><a href="#相似矩阵" class="headerlink" title="相似矩阵"></a>相似矩阵</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>称两矩阵$A,B$相似，当且仅当存在可逆矩阵$C$，使得</p>
<script type="math/tex; mode=display">
A=C^{-1}BC</script><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><ol>
<li>相似关系是等价关系.</li>
</ol>
<ul>
<li>自反性: $A$与$A$本身相似</li>
<li>对称性: $A$相似于$B$, 则$B$相似于$A$</li>
<li>传递性: $A$相似于$B$, $B$相似于$C$, 则$A$相似于$C$.</li>
</ul>
<ol>
<li>相似矩阵具有一系列相同的特点.</li>
</ol>
<ul>
<li>两者的秩相等；</li>
<li>两者的行列式值相等；</li>
<li>两者的迹相等；</li>
<li>两者拥有同样的特征值，但相应的特征向量一般不同；</li>
<li>两者拥有同样的特征多项式；<br>（我们可以利用这些必要条件来判断两个矩阵是否相似）</li>
</ul>
<ol>
<li>相似矩阵具有相同的可逆性，当它们可逆时，则它们的逆矩阵也相似。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>三角函数的正整数幂的不定积分</title>
    <url>/2020/simple-triangular-indefinite-integral/</url>
    <content><![CDATA[<p>啊说真的排版好麻烦明天再来调吧</p>
<h2 id="Knowledge-Base"><a href="#Knowledge-Base" class="headerlink" title="Knowledge Base"></a>Knowledge Base</h2><ul>
<li>换元法（凑微分法）</li>
</ul>
<script type="math/tex; mode=display">
\int f'(\phi(x))\phi'(x)dx = \int f'(\phi(x))d\phi(x) = f(\phi(x))+C</script><script type="math/tex; mode=display">
\int f'(u)du = \int f'(\phi(x)) \phi'(x)dx = g(x)+C = g(\phi^{-1} (x))+C</script><ul>
<li>分部积分法</li>
</ul>
<h2 id="关于三角函数的幂的积分"><a href="#关于三角函数的幂的积分" class="headerlink" title="关于三角函数的幂的积分"></a>关于三角函数的幂的积分</h2><h3 id="sin-或-cos-的幂"><a href="#sin-或-cos-的幂" class="headerlink" title="sin 或 cos 的幂"></a>sin 或 cos 的幂</h3><p>若指数中存在奇数：</p>
<script type="math/tex; mode=display">
\int \cos^7x \sin^{10}xdx</script><ol>
<li>选定 cos 与 sin 中次幂较低，且为奇数的一个，使用凑微分法</li>
<li>使用公式 $sin^2x+cos^2x=1$ 替换掉剩下的项</li>
</ol>
<p><em>Solve:</em></p>
<script type="math/tex; mode=display">
\begin{aligned}
&\int \cos ^{7} x \sin ^{10} x d x \\
&=\int \cos ^{6} x \sin ^{10} x d \sin x \\
&=\int\left(1-\sin ^{2} x\right)^{3} \sin ^{10} x d \sin x \\
(t &=\sin x) \\
&= \int\left(1-3 t^{2}+3 t^{4}-t^{6}\right) t^{10} d t \\
&=\int\left(t^{10}-3 t^{12}+3 t^{14}-t^{16}\right) d t \\
&=\frac {t^{11}} {11}-\frac{3}{13} t^{13}+\frac{3}{15} t^{15}-\frac{1}{17} t^{17}+C \\
&=\frac{1}{11} \sin ^{11} x-\frac{3}{13} \sin ^{2} x+\frac{1}{5} \sin ^{10} x-\frac{1}{17} \sin ^{17} x+C
\end{aligned}</script><p>若指数中不存在奇数：</p>
<script type="math/tex; mode=display">
\quad \int \cos ^{2} x \sin ^{4} x d x</script><ol>
<li>使用二倍角公式</li>
<li>展开后分别积分</li>
</ol>
<p><em>Solve:</em></p>
<p>$\quad \int \cos ^{2} x \sin ^{4} x d x=\int \frac{1+\cos 2 x}{2} \frac{\left(1-\cos ^{2} x\right)^{2}}{4} d x$<br>$=\frac{1}{8} \int\left(\cos ^{2} 2 x-2 \cos 2 x+1\right)(1+\cos 2 x) d x$<br>$=\frac{1}{8} \int\left(\cos ^{3} 2 x-\cos ^{2} 2 x-\cos 2 x+1\right) d x$<br>$=\frac{1}{8} \int \cos ^{3} 2 x d x-\frac{1}{8} \int \cos ^{2} 2 x d x-\frac{1}{8} \int \cos 2 x d x+\frac{1}{8} \int d x$<br>$=\frac{1}{8} \cdot \frac{1}{2} \int \cos ^{2} 2x d \sin 2 x-\frac{1}{8} \int \frac{1+\cos 4 x}{2} d x-\frac{1}{8} \cdot \frac{1}{2} \sin 2 x+\frac{1}{8} x+C<br>$</p>
<p>$=\frac{1}{16} \int d \sin 2 x-\frac{1}{16} \int \sin ^{2} 2 x d \sin 2 x-\frac{1}{16} x-\frac{1}{16} \cdot \frac{1}{4} \sin 4 x-\frac{1}{16} \sin 2 x+\frac{1}{8} x+C$</p>
<p>$=\frac{x}{16}-\frac{\sin^32x}{48}-\frac{\sin4x}{64}+C$</p>
<h3 id="tan-与-cot-的幂"><a href="#tan-与-cot-的幂" class="headerlink" title="tan 与 cot 的幂"></a>tan 与 cot 的幂</h3><script type="math/tex; mode=display">
\int \tan ^{4} x d x</script><p>使用公式 $ \tan ^{2} x=\sec ^{2} x-1 $</p>
<script type="math/tex; mode=display">
\begin{array}{l}
\int \tan ^{0} x d x=\int d x=x+C \\
\int \tan ^{1} x d x=\int \frac{\sin x}{\cos x} d x=-\int \frac{1}{\cos x} d \cos x=-\ln |\cos x|+C \\
\qquad=\ln |\sec x|+C \\
\end{array}</script><script type="math/tex; mode=display">
\begin{aligned}
I_{n} &=\int \tan ^{n} x d x \\
&=\int \tan ^{n-2} x \tan ^{2} x d x \\
&=\int \tan ^{n-2} x\left(\sec ^{2} x-1\right) d x \\
&=\int \tan ^{n-2} x \sec ^{2} x d x-\int \tan ^{n-2} x d x \\
&=\int \tan ^{n-2} x d \tan x-\int \tan ^{n-2} x d x \\
&=\frac{1}{n-1} \cdot \tan ^{n-1} x-I_{n-2}
\end{aligned}</script><p><em>Solve:</em></p>
<script type="math/tex; mode=display">
\begin{aligned}
\int \tan ^{4} x d x &=\int \tan ^{2} x\left(\sec ^{2} x-1\right) d x \\
&=\int \tan ^{2} x \sec ^{2} x d x-\int \tan ^{2} x d x \\
&=\frac{1}{3} \tan ^{3} x-\int \sec ^{2} x d x+\int d x \\
&=\frac{1}{3} \tan ^{3} x-\tan x+x+C
\end{aligned}</script><p>cot 的幂读者自证不难.</p>
<h3 id="sec-与-csc-的幂"><a href="#sec-与-csc-的幂" class="headerlink" title="sec 与 csc 的幂"></a>sec 与 csc 的幂</h3><script type="math/tex; mode=display">
\begin{aligned}
\int \sec x d x &=\int \frac{(\sec x)(\sec x+\tan x)}{\sec x+\tan x} d x \\
&=\int \frac{\sec x \tan x+\sec ^{2} x}{\sec x+\tan x} d x \\
&=\ln |\sec x+\tan x|+C \\
\int \sec ^{2} x d x &=\tan x+C
\end{aligned}</script><script type="math/tex; mode=display">
\begin{aligned}
\int \sec ^{n} x d x &=\int \sec ^{n-2} x \sec ^{2} x d x \\
&=\int \sec ^{n-2} x d \tan x \\
&=\sec ^{n-2} x \tan x-\int \tan x(n-2) \sec ^{n-3} x \sec x \tan x d x \\
&=\sec ^{n-2} \tan x-(n-2) \int \sec ^{n-2} x \tan ^{2} x d x \\
&=\sec ^{n-2} x \tan x-(n-2) \int \sec ^{n-2} x\left(\sec ^{2} x-1\right) d x \\
&=\sec ^{n-2} x \tan x-(n-2) \int \sec ^{n} x d x+(n-2) \int \sec ^{n-2} x d x \\
\end{aligned}</script><p>因此我们有：</p>
<script type="math/tex; mode=display">
\int \sec ^{n} x d x=\frac{1}{n-1} \sec ^{n-2} x \tan x+\frac{n-2}{n-1} \int \sec ^{n-2} x d x</script><p>csc 的幂同理显然.</p>
]]></content>
      <tags>
        <tag>Calculus</tag>
      </tags>
  </entry>
</search>
