<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据的离散化</title>
    <url>/2020/data-discreatization/</url>
    <content><![CDATA[<h2 id="数据的离散化处理"><a href="#数据的离散化处理" class="headerlink" title="数据的离散化处理"></a>数据的离散化处理</h2><p>什么是<strong>离散化</strong>？</p>
<p>离散化，把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。</p>
<p>通俗的说，离散化是在不改变数据相对大小的条件下，对数据进行相应的缩小。例如：</p>
<ul>
<li><p>原数据：1,999,100000,15；处理后：1,3,4,2；</p>
</li>
<li><p>原数据：{100,200}，{20,50000}，{1,400}；处理后：{3,4}，{2,6}，{1,5}；</p>
</li>
</ul>
<p>例子：洛谷P1908，树状数组求逆序对时的应用</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1908">https://www.luogu.com.cn/problem/P1908</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>2020-01 日记</title>
    <url>/2021/diary-2021-01/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="【■■■ - 密码错误 - ■■■】" data-whm="Oh, these decrypted content cannot be verified, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="73ecc6c9e0151e191b1abf3c3eecca10110b43277dc884e0601a50b5499b90fc">2827033f81fcfb979d6a35f655f74dad666f139907e7dd6158a7a05612428cef2dc4832a96d82f8600ac7870d88d59f3b217351a137527de34b6171e25e654b99d1dbbbeaf73d719d4c5df94654c37516a690eef29c6363c38771788ca6721a9aa2f73ef42ff831a76ff43e7c95be066d87ef8b427c0cd8e72701800390a6c30a2010e2b0382fa3988ff24b8e3cbe5ab44083143e97f6bde882c62ba7e8fb332143cf952a615a66eec9204e8f1c8fc4fb7d48ac10aeb6c46939976f4364030f6f655f08de9a64be3f5cd1599631617a12c467bcdbd0783915b8a47252bea543a9d8207d2d33321dc7ee4b346271f5f4d2c41bcfedb905820fa5a7275c8f2d20974ba8e30253b4c77520439b79c54e642df9d9358eb55984eda56c9b084084df25eec1105d18ca3d64b47dade2937f670b1ac8f7faa4f44d84f77e003eb4df6fc0e39b14f96071423a3ef17452e21711c9ed950d83cfb9f786d5a0dd6c9094f205f8e6387cc83fff9ff3a2aaceb4152fdeffc6f5da13a628f3a3332a66050c8435cd17c94df3818790f38baf40e87b3b9ecdd188727ce8c5dc9c0c605ab1213bc9684c0c6e8ac76db3f0469c05c89402f77385365bb1de0d5f576918f5224b0bd76f32319958bca75bbbb2b2a207aa7080f7bda948cef595fb92632786c26731219f7f68a863e580edadba79cab5a1f2724e94418e9005b146f312e2093c4fa6670ee5115554bf71aaa27714801535f56ae59b6975ffcfafb52455b2b362eb96097c9ed692db93464e6361e7cc27612c4d30a44b90ce8bd8ccacb9cb0f77265411eaf0b3afc0f96db3bceb89b12b33fdff95dee12aa084027e7f122e8eb11908626e7a69b74f279da118ef35fc474dd15529ef2067d7b8712f51e17d5f83da35d5e1578736644480c96c7b958f1583637303149f26741627f24741e590ba71f0994e1aee525ed2919b0a5d7fe034b57f7f589c78a01cdf74719dad94d07b0cc7d3d1a5509b21d5e78b5cb1d379c63708054b10eac36a1eedbb047f40e364789eac0debc576551d230c0b10744f72a62ac019ff43853dd0764bc247071b4109ab3a22786e2a4cec7ab8d087ad216affcf951e833069ef4c1c96ff326908f925323ba91ffc1b1fb146935a6727f593d06acb8fac0d9aa056f39c409b0b44e37d8b7f3e4801c85efd188bb2c4878ea11eee65aa8ce1fb5b82fcded65f402a493e20ca4afe6f06965402bc90c9ebbacc6fbe7f4d789bee8235d2cad7ae1bc914ba763a69e9f77819e22c0c7ad187ec776247a482411c1c34f3504bcd054a5ede5442749f4d71ab94c64067e6a8d743d22b65854daa7e3ba1e020301abf76f748540870f8b93893886d6816917416832bdc0bfeebb6170d9e224ab69bde386644ed4b5f167dbea5b30adc933872eb72957fac4cbc2f01e017e73ca31328615f67d89792c8a639b4a67199bcc028af38c838e2f4b881088e03cd7fcb4be43808d6a06308f14d35a1eec4283a33089661a5a2e1bdf43e0a426bd3aa545b90e4443a103300a4eb6897bbf30fe463486d769dbe677ca1de70c2a408e8d683cf19216823bcc6e001aeef9ed8859dad3a7be81416adcbaa9bfdad244c4de84ec5fd9ea13d78701b01ce186c9ef988ae025287d574b671f198ff7755eeae4fe8cea2435998a7267f35b85c4983b9075b222dd584993f632030a478ac17725861d3be2dc541cd3e3b4914f69647d725fb76a5e33348dd13e7f06b0c11a1840f5e0625dbae27257100c0f9d7f3ec8b56f64c37e53c01919aeb9b2868c0950e330c00d80530e4b6c2b0148d8d53bcb6a5e2edc322db4d010a8f6a016e8e1eac9655b012e945756091c6acd1d8c028e930aabe675d3e961d2323922dedbad060066677ee2fc95a8126624adce8a6ad54279e32b3fb09a435cca25caa817c85f0ad10bea7f5abc6013618679934ef0c23100cee261cefc52867226b170bd28626a6d3df2d368f43127fcf029e077903ceec4af2f92f9ad833e63ad8d6a5e5b1f5809b73c769ddfaf9daec26a648c2f7a886c619120846937ea333e76c0dd6cbeb5606f321cc94002c3da7c4373bd88992cc611a27e42ec4a3e1565ac7c87825e06d7f453f202be33bbdd1378eb33faefd1b2f7f7aa356f2f1133f8a6597bb1f8a20ee1b57fe98a4ed06f09011c67f80c03f552b156c305e5564897ceb93a6f9a428c93010559e6413e8b5a877c294364b3fe781b2bc61ebfb6463124d82a8d5da511397da13f3a2fe45c9efab553ba0bdb0f1e51c4a98897af19d97b9a672efbe088a3cf6698057c2abc6942b22a956b9d138233e231795661f9f1662c8ea50a50a7b491d6ed98c766c6167ced6f8f9e3a0b00cea6331a07f898d5711355196cc0164fbac1a33acd752ada94e05c70581cd45dd0e708bad79353fc697b5310eb464d0cf3254c3a651cd73ad1090ee1f98c4dcb6f81ad6afa0d53cb84f4151c3ec7fa725cabb0e26a5c4013f9cb41dec3eb863cce3325894274e2a6c4779486d593981387443f95a5f6c1229aa83cce6353383ea6defbfd3a4039ffb221f1369d0fe7f563efefda9cb3f97e7006f597510ef91b8648a6994161ee413c912f44c19126a7178edfce02f680a69459e1641f3047145c6862d02ea6c7c3f710f7182e3213c36c50a9d4b1864a9ffa499d7f563f49dc5a4872e9547cbef6d07b75465c2f51367c90393961c24e710c314941b91cffabdb051cb7ab18b9695ce13385aec6f2eab20167affab1aad8e2ce55008815da612fb9e644b95b8c6fdc819d51c035d7ba652ed8589af63b71d91f25c3042e65902ee1c079d407b3441ee63ed3a91f163628349d0cc75b4530f834e7da8c3d1e87b1ce3077fa68326b44b83f655c06c93be47b43109650d0df242e687c27251690451e46a187b36595ce8357d56f42d8ec05c4d5828b347cd30c7934c90c8abf7f97168969851fd4eb25b63e1bac41e216ad044d223c3ce8ef088c4f46a3a6d7335b623c8d19dbfac270706a70543bd1790ca3752ebba5bc6c01496e3dfa17d02df3055ce8dcd53f1fe77b0b7b8a26a46205810c46df05271ea685fc183e538bdfefd4e20a26abd998aa64d33360b003c69d429249958c0db13667ea62b8a9d163b21cde16cd15fe13d6cf60991a66f6fe46076c77b96ecbb5d53cc19b5da1af2b70049be6c32c1d7778c2d717a2baa4c41a916fb78a3366099e7ba83ff4af65fb0d2a42557dbdf686ab0dad451fb6afc8d658aa2edb11f7a7e07f67dad40cd4a7a2a71ea93d904917a346e55f8990b05813317fc988c204781a62f9edb17eef36360cfb678ea590f69de1795ebc190fffecdf3d7aa876cf2b0f2a875b5302764753e332326ae55dd98689106eab184c5136ece7ed231db339f6fbd91294e6695b3779f824ad61be6cc8a3aad1ff688ccbc5b42404bc328cab2442c7be7e7b4a2ccd9fbb5b018ed5d02f38e6f26738f48709855234839debee7cef0aa947bbe83f7e7ef86ccf4a70620f7805acc030c59af67034c620718dae3c3a8c7e5780f8107214cbaab9b7e32ac3b0abfc722dca569963d3c968a633e5852305472e19d8df9bae75e1280ea51bab47cdfe66cd18f7ca1c044b411c88f0f2ce0f7d952ed3af6c6a68402fb29550c243ed5d60e77ffa28080aae2e85b371307be7e6017ee9432772321b6188b5183ae9831da9905da564f3d1de00695e6c6e324489b8cb14f750e330149904cdc3a86f5cd9830967cbc2fd4d1f191ec95a37f875263fe6e0286e0cb2301a28dfb76e2106b99978d68b260bb5ed7eb982a707cc4073770e342d6e4fa29d6262081689b68d0c4c290825ff22048b55b2b244835c48e815eb32726fc46cd0efeaa984316a4d484666bfc708707c7645c15933a3fe0936cf71140b873c941d41bd8e3c386d8230ba6943b4edae11d2657fca3b777beb5b5e8f6770ae9fb303e5c968bc496527bbddfe916a0fcb8e575290494f720547aea0019ed331c2a1b6151ecdf01d45486f80bc12234527eb40a20ab6788f858ba7d6fd6eff5dbd4c52381de68b9fe2e7d98f4938d6d29fdcebf0371cfc88eecc242ca4772dac1fb154262fff386941352b95bdafdfad734333ea954fe5da76142ad8df59f383c855771ea9dea9e802269145990d1c7f6254b107eb750bc7400b6ac978b87ca5f5da77413749aabeb8303194f521f7fa86b28dc6b3db1ceea01319487bfebe433d33286fcfae13ed363a6aa091a54fd25cab906b937fe38d232536b1fe14fd1163cc44c536031fd84836df513c35794f8019d0db40139ec255ce77840557a126d929f947a9b8eb00375db03f448f57b3590d1b02343e637b7d925d466f0d0db874b87b51b1851e52484ea1915e91a0a4b37749530dfadc7fb278959ea1f2397200c7ff239c6df6ec7431131165dc91cd757fb3057ac0e053aea16cc8b632a9c15c72c07243995064363e933f8079ed841ee23a8451300bcfb960d672e2fac821c1cfabfd56356875720e21b9e64a214b3b54cf014ad44a5cd3ff50da60e23ad4860aa704a1dfaf3d486bea9cca55d60b774c242e343321574f77d2e72aebc0d1c4b53bab96e5f898ef3580797824eac0d6729d95150e9a6aa419c5da5c635b289e16c7426382129cc79fd7c6ee0e434e044b19250626a9e8265f74c979e6e2344d14fbe890fc4832bf8046b2c0c3f63057e9a95e68c0f9a828ff0453545a87f7e9ce2fb1789f2c54609d7f87d7b10ed5d9a8192a51cdfb2e373ba3bc7711ef604e42c99b1042b1604aa7deb60f4f56ab4473ab7cc5f569966ef754d785b9839fc2cb3944147f42702451480b0cebd285afe2e2da4f573b23904cf28121dc41fd9944988e21fac9e2e216ce50f06d339fffdab3a77c20b0854e7a192c31c300e4267f203ad5fed3eddd02430ca4451ab0ad47c7d75ded46852aab8d8abc6c8becbfd8e8f54a49cf3f3596448c7757464bd4eef9564d8ee138d502f0b8f1ca045ca569da1978450dd2936a83af4dc197f32a5713ad25ee1c425e290ef559c59bd6dce612a1e2c087c4ab1e1e50600e7056144347a6938e610a623fb068483deba720dbad901fee8b06003efd72af7e547668e1a06a278f0c43e1b5839df3a4f29d79a3332066d9c2f1d5cd2505dec6a017073973ad34f14b281edff42787d47299f5ee5b8dff8a2a14922693305d724d1378ada241eee53e928a997a88551d85a37d2d73879ff9809d4f1026e35e7871623a7b97f041523f6e9b149463615b25936b10a7a8f90dbd36a185ad853dd922ffa623e39a0f37ba77204741e02fbf87e50de297134d37ddfcd07fe27ddbf8598407648444a21270fad6eba192e182ad49abe09f61c6a66e9f23afe8ce3ed6f3c3aeee61f1e0f745f34e4b428718c0d99ee89ecc963f1a62bfa07c4e7b534833bc36774b38eef84b89741139a7ffaaf02ca8bf228700db1338ddb3312316970448858304bce7cd68ebedbfe17f63392cbec69ba78de522037e0e0189d7144b8a2121f3a82b2951844d59b1718ffab5e19b7c81a8cb1f19592eb30d80bd9c2fb5b4e2ce56683e758e3b7c9295d4f7d15650858be2103326e4cfcf001d0b7f7ed5bd6b66dab2346cb0ee5311e6d979a8d77572f91a9ca9fbcf59adfb6e2714b0b00df6685593b04539a8221611d5fb095e32f8a9c0ac220cb2c2fbc50ae11d8a6bcc392ab457fdc80a297e20bf78c2a5d74bdb919bdd8420882444b6e185118e692f45a9a5cdbe69152fe965f17ea0ea6500614b6c17b9db4fbc810fc194856bb3efd977e544eebb7793b4c421762980327ee9515d03b886d3c6f6d1909554557b6f39a07991d104e9bfc2ae69c0aa4b210cbec73fb60095745bd8cf7a8eb85ea3dc6cdfb7ce7d8985ede74685e57ac71af24fc698b4903f23f9dcafd5c0ef4497602123c732b515fe7dfc1590a699e336b81558669c1a86c96c865af2e94c9bb7e20c9ae46285f32920e214c58c679952ea3efd0b72b6efd07064a4ecefd1717c4e72c1facfd9979b3c59410c11bb7cce5340c57fd7c65736363ece30274c495cb521180008f4f5ff09a9072c24b6ca164f9972b13835fa1bb702f2960e8f8d8f27b320d2fa375ac4e8dbb71664b69ea9b9cad375f332548311de507e9c9dff21a5d723e68f4ab49bab76ba6e99e751f06dc75084029f98b730848923c74e4ddea0a4d42cf7322547403bacf6ef15a57efeab1b99ed2601aa300e14b3e9ecb61b687c930a17123da5ff1210f85433c1ca4defc98d89d7e400c96330766327d8618f17473e80cb4264c94e7691f427d1df5c27cce28e7c45677514cdcadc79c75616c4ddeea40d6f6ad500cb49e814695e518112ef88d59544d06ca8026709aa5e847ed3f8478720f79a64e98a7d5a78997a8661792a5016a0e87e72000469874eb75f35df2e940eab05bd7fab8f54b1e436dc4118c8ec3e415914495975720113800fd7f9205b57a7c8f5265d72fcf181a2ecf529fa05bb2f3e99141636916e5fa260e8b1258791e8e58750fe502774dff9d56386af3dbdf8d189c5f24820c47b879927ff212562c608a9c71356352818e9924aa5fc9adff059fcc787736d27a0da32681f97079def87bd3aaff6b5e67a8dccf298d395d730168da46cb13f15e3fe25b7b101bba3f511587874ac99fbab07a14f3bc3cd19cb681d777237653f58a7c36dc12819cf4e0ed6af2f1a7b0101ad3b85adadc8e1b87a7bee4d0c7c80b6fe3fa87dc96f400f457c2cccc795e405b6077429f6e53776af05b97eb70fa20fe953c052949abd03486851607a44c9579694dcc4830606a76908fe707a6ad989b345c8b0bd0e1a4766f707dbb3cdca6a13ef7ef2504cfad382f6ae719855d0dca114864cad314519040a1788536e703008ef749b4f4fc5deb83a091572a70ef8671b5dbcbdae8c646534913c1d86160c12ef7366a492c8ccc282c0ee7938c6a9ba675762aa6255b4446887687365e8ec9172f6d1a715ecd0960722e8480542ff03bf8fa81b0a8196063c9b2783c929d1aee975884fd06ff7dfa731fddaaa7efc0c79f057d00b997ebdbec65d4a97ac3c2c118772d1839381823af8eefe5dc47ea343a1b72c78b4b1eb126ecd2e7692f572056b12be224502102a7206ba7870496cbf5ddeb24c1adb509a89288cc558100a7fd11d6359631bb7f4e5e934a6b5edc8d1b7f04dc4fd253da2ed5ee0d0825d8910c3b269a4e1560bd390de10be77118b5d4b6502cfcd4ddfa031596e7abdc51d2165207818f441be803fa26c228bef94d1c16f9833c585978f95ade4359a440a66d0564477c22456f5357371dd0454eefd5d21403cd1bd0a34a5a0b6f61bb3f34858db899506a81b221f92dbe9af79cf14147e5ca29b11a8ff8e67918fed6aa86ab4d93b4cb3dfc4583374848b1b183e51ab0480990efecbb05d29eb526f99689dd8c6b838a5a2debe457151892d96e6a575bc7c7c68a7c13ed5e11811a139fde27bfcd0d23535adadd9cadea7cef0761e9ff5a5a9d4def3c76e07a6a00364865437a377c6c9660499f457be83fe6f45b1c4788181d30a9f683d5933c543eefe741991b4278458b3f44e3d984017d72a62b218fc233b2a89876d95a363dd588ec68d9290d7579571384dd307c0d93ba3f5811008c7dcfb5d9363492f9408207a702d4a459d71f041ad269f18fa47e2ce4930235a76b816a2135236ef74b5395ce4c331774247ba1ca0735044d3b454810a737168d08718c4c4268396d17a62e9dd8cd02d20cff6d31d90a866256244b26d2cc0855db2a578590a68cd914ed7756281706cf076b791c3aa52fcc8eb7664210bcb36a0c08c4629cf599c6c9cb9a612eb84cbc5a55144e10a5ebc694f791b4273a6ea9a15786b6a6fcb4c407db087b1ff25441560096f4a2a036cf05720f2ab5d9d2dae3e4bc644f02ed8b8e1d38c42910cd66ea7b5f9f13d2df91753a51954c2701c103b92b3f0c89f9f3cc4fcfb4a433b865159c5c86764aa1249c9a9e9de8950fd7f3915713edb791820abce04043ebc29b5e77f0e3e06e302cb6afe37abbaf2f3849e09b381b0b8ada601f0dce045b684d2e5871b23bb5cf1307f02c14e6552f9444dbb0172afb79b64b8abaf56be78281b45eec4bc513b10a072e78ad2935d8923b55a891769ba61b295734af48a01e80ef666cb44839f0ff32ce7777784788181803d5e278e7af94421ea83399ff752045269fbd87c5f23c59640dcdebf8a37b3a65bbd7f4c9af6e38fe76000d6bb8845a5fb66e64d7d45ebafb0c3193c2dd3bb9e1972fa6f9f7f88654c3e23dc03255607099cd525b7fa492c85854c5048005c91a78ba75f09844fd3c243e80b051675d5cc2b1c58ee677bf02ae2fabc4754bd5795131971ca07e4509ad0cd89700783a0f0b1f25fc72c7c26c18d9f4d405605dc02d582126cd6b84d2d88cf45cb1122a9e06f96284984b16f64229f4dcc0912c468a7811460aa0a095e91d1e0346e54eb86f5e4b82d6769d5c7614585bd90551c78fc46b8b11cbb5f600d64e7ba4604a526060b53dced550498fe76da99370d4ca9fc40696172fed1124f03c2ae29795e2648f1dbfd4af96daf8f51ae2557c99a85ddaeef2d099ba9ee0576b361af5fd13d0d37ec079cdfb2b552b0d646db8cd559ced7c531572d46f970cc0888d9b81efab4f2332a85db8b9d4f95416911d9da37074fc08759e9a59a74b8245ad39bda9a7d2dcebd4511b8b1e1959cdd1d56683e2b932199372e23551c8a60c22e9ae1b61b2d615600292e36d7a374f462f25c82669c5eb07a0565a03877ccb6143e3624489a8f50e7cbc0a3c063c512592574ad569345007547c2edcc5292c4e9f42202ad1bacb1994823820122a3d61a2f4eda20867a420d289efdbb8a0c87562ed241522bdd24ec375d53fe3698b87785f5de4ae2ea5b9e73f0658906bf99561e6be46fa833f63bf53632b2be1a1687d788b84ffcdd65dd0617035841fb23db56e6bc92593ae7c2eec61bced6f00141fcef32ffce6177018e0270e4520179218ccb6a2326961bd04287f140029221de93e1f203cfd4cb3706b41b56723a860ec2371be8a4785fc1b8924775fb10450a56bcfc8b68574021e8c9729592ab589f370167beb7bf59312f0c228aa89618122f99fca63553182fb909dfe0e197aa1038f4be4917d4b1e840d043111db54ee061f93c33566d85d57084501a942e46e2d1d49b3d30459d5900603221747a0bf43a7680f131e34414a1f4c3a2951c1c9219108d9f93e483f4b854465fea8fd3b53ff1a48956cc2bf050635057ea6aade192bc1d56cc82ac5f18c7cdaaea1d8e17019334b1643f6e1897119e1e2a30960889556650042317d67167c1ab9418a13e05ee67be7b85d26edc104ab3f9ca229c79880c4827ab07971fbcb3a51314f98211fb09557faae0a8472ba64fb8a1195c0cadfbceb6935c686d61237d1583a0be0e6c61379efdc1b328a735cad07c40fbec1d35bfbfc0092a8b204a141aca1a38c0e75247943184c4d6d069cd1c35c76e3dfb3bd234e6cd7ca55aecee63ed3de25b8534943cce7ede1e95c0dab2bb244872fb7792459c9f7e226eddfe19eef30abda1074e97315652c6659ff392cda29737d7ea12af3119d8dcc9ba22519d272c81a782e4fc81a0e518709e7110a12a855f4bd9175b6330b54ac1591472a206cdc0913b929564807ccfcfe7c1717ae1074846a54ed621e388d6bcc57228fb9b6faeb0665c2f7007eea6ff433aa9279497e2bb5f9aa967697bc7d21097c301d307a98e492dffbaf59aeac2d73f4e93bc5efc8365b9bbbd84568c0d4f3480db0e9bc851d25bc0841b9b3237459333bae847e6e3cf9f039ece6b85b614ec71af3c6c75fc1ea01d78a1f5c43e19ef7e12f636b6cc0689de7b7ed80d2b4b0a971a58b0528a5937866fb74699e396dd9368fc05f86ba9814d221ac0f464d858a2111f5e68875dd692142a0e6469d3fe9014cea2dcaf7430a70008300de209fa2bf6e3de699af414f77e3f1020911e45f806cfd2444f26602c9789d74934f2770649f4572267aa7571dba2f03083b1f4330a4872d0f0df16995f12b75097438d61b673baef21159fd609e7538abe0d4e5bfa5820021b279b39cc3141828fcf908ecd976fe1d9443c46626e9a58422e399f68a23b2e38dda9230b25717a77e0782c1ffb73356ec415ba4a0a6e19b04870bf0122a8d9163dbc557fd44bebd211665cb0bf13013a16f76bd864844b2a4045adf76f19fece309a292b5fa3ccb68c6d6d1b6375855983a545136696b51010639ba92aaec393ea58e89a5760a36893edd72dbecb12fe6eaff8361f6d1688e9eae8be8b95d75b7d6d8fa0fa9f4e71ccdbe864c70b30d81586d848e1e56353025353bd4fd9bd20ac7f14a5f697beca031662aef2502d9192d479beb7d6621149fbe982e8c4da543a7664e21fce4d218039c109ceb0410d2f2e0466419b97b5011d63793621742ab67d2fa257cba4567e667ad708759f7a53cc4eb2cc2250d4795586f839326093fecb0696afa08e05b6f490da3c185d37d13c833eaf8fd5c682747e21bf618bb68aa8a296fb6220ff038fb52d7e8cfb6a584729df88b746c6f74cd092dccb10a3eb9d22f6ba450bdc280a97ce6430b09a338114b6a3271037d24bba56e229d41f143ca916694b0e865998ebe7a986474f8e601c19455b8fc53acccb9eae136343932732dc1b09f0dc299223d9c177cff3f3df75a90a66ec2c9a36a8d77231cff839c047e311d2fce0f08a0f91df2e98f0cfa5482ef5ce4a80292cfc52e2296b99fe69469a87ff45e1083528d5fdca55503e6720cf1c1d2baf1d31c54a363f3e6018fb316fe0060295d72d1f3ac9387e00be4b7e9900c0052f1d717c1f137365afb9de0f124bd61bc6cb20dd91f45227886fd7766baa625b77fbc2ec51be9af20ab3907c94062ee919cdafafb841c64239b19b2e509519d74001a8cb82a9f2d8847b0691b9ca9820a4e2759abbf98ef04d5b059870f6a9a10255917f51611a493406d4e1bc136c641c4284ecd76ddb10bdd481f3f520d6ee8e204bbe83e251c027dd87824b8466b987e07629d9c93fcc43d43e0f97b1273b455d537095aea2d923ea61f9fdb796511ae37e832df4cb702b91669489a92ad5bc2416e657c7a65944ad7b8c31b98dbaab4ec00ba4c8591fb1c9ae94f1baecb21b08318577c30b6762ff7b79a9f2660757de5ac044da5f07ac5667448692324d16648c7d501af9db7f8ba3ce33adb5646b2214d10a0b23ded6b3938c29cbc5625c0e6812a7302b735233d0a1e56d0490670d794a78b0057e0536b46ded7f2af0d70223262ffc8e9713351c1cab9fe74984dd603cf2bc6f4fa5794b0f5691d8b92605b8dbedbe052f93fb7e80512afef9eae87b0e738d933b2abf000887b0a11bbf6b4de1412f3b79eb5e0b1e0dc3f968a61bf74fc410a13e4da28197c6d29354280091f7492f22f0f256f923d67e228a283ff09f9f42ff4b363c7c377d33d16013ca03a1c973eb235be7fdf46f3418f5cef4026e1a0929e67da6468d2fdc9dd23c1eb9e0bb6cf3dd7bad1323ec84d3a7d427920ab86b27f1d478621e6ce4c8b9fe3abd831ff80e0a071b060b4d1e8b4ee0ccdde934d016709ea46300a92e1c5d5354b6067816ec66a57497b6dbd751eb82ef08f4c73fddad4623ecaa885b45906d82e103450e39499ca5efaf804aab966984bcf67eb985ee4dbfc0dce96863bc8b10a5e4644d88660818135d3750eb1d8762f2f05df88c52a58bd3678e8271fa40f487d1e82f71bb19a5e570ee3b96a9b363eabeb1639e5a98b673eddb496582643bc5d1edaf5ad570c7371da6866a955f88d75f83a8bbd2062a1e2b6b8b92b3741f88721dd84d138d9329e49e6f9c6c7c3a3f5536c0598e2dddd9c4a896aafcb09dd7656ad87d3d96c4736c3b075c0c93ce7fa7d1db5700d54a55100466ceb3f28cdf132a3da469802ff142345b654ab19627de6a94a30b91db75088bd115bef332286df1f7ec59800f1a619899ab466e9abcbca83f5efe1657c1778809491bd941c34f72f2708891413eecbb43360e33e776c303024f549968e294570fd8b5e06eacb9ffe4f52b925888ca38d8de0afaafb064bad728d958aad4288ca97895867eb76051fc9791e0c1c9fd35a7404f5e91f84a73c5c27ec4875c1b4c0861d0140e1fc96b719583049a3077ad0789f6f8d499c591a0c094429d0e937e6fd2bea92fec09202a38bb4db954008a89f5a72df60abcb039dd4d48860bd17dce7ce1bbdda248a4acfdbefec07e84a36ce19b13d75f519f39e128c330d2bed58f9556f0c750dc5fa9b3a91907e1c33afc2193bd510c1fcef1f29e5d46e2c2f558b56b0e39cd7ba18f1b2f77570ee2909724ec92198ec01713800a02450b977c4a0b76d5b4d92840d44487215b8e46833603f63130a271d2f92c5b169eb69d1b9b365b04634b5a842b264fcad1e8aad0636c9071557ab826be3b039307f1480903476be54f5a5ec1560293b2d106edda1469a37aadb1d10734466950404a74ed49f8c840a1c49a60dd78b393c2e7683663b5c6fa2e2355f3daff803fc8709168ca51aec2eb995fc583b438a2cfa5586ab2c38881047a51583080fa49c112ab000e311174051a2f170cae6d5fd0a5651957245af0689e307d9972099bb2d9ce2eeb3703420999cc291a6411483bd0ed8b58a885d3f74d25d44ad7da5a7d68b02f64b7548c4714ded0c47343713f17006465842c7382557716c7b03234769c7590d49e9ec234dd4c45e90ca5f8e3787825b56d271d5ef7442659d0b6b84d94e28765bef34e043f9dab205be21cea42c732287811732b8e3fa2f7ac7201656fc1438a47178de304dfec76120f540dc4c95215582819dcca7dc4616a132a69dde01a9993f42efb04085df9589b2d48f020c4cabaa75832e8cab0050a0b3c5eb28250aa112395ec00b4db48ee0e31cf6c0d3a81bcdd76a670098f26b0704cb54431221c01f1b30d3706ae3ed555d525eb987a30c84e86b8adb6989f79fab1250a1a3dd83a6a5d9e7ede727907c9db960595a7b3129e86209a3b515e28d3664f847eceaa770a38f3025b7c51c611c18bdae47288bc1079151ef10fd1e863b40d7ba1ce090252f1d9ab611f4c7b0d87cf476823e1f56c315e25168b7dbc22a90e6c8c948e161347f63f872ac5a21f1eb27a26aa1064e065b9b264e834aa55cc2317e1e60d6b920c5c92dfbace9b740678cefb7e02fd13ea1c98047130a817aaab476732a026b39654b3d4c84980629e33abf4c672f34edcef05712aac322edc2ef545f9765f927ba5e72414272ae6ef8e3e81fc953b0558a7867d7e528b00cfb98bc40bf6e73988b96818883893935e52c3dba7d54a5978fefc246992ef91b526c19b080df665bb2abfc18bfc79260fa458f1355d14eff89a0083a52c75fb86f7c79e949f7c9635a6b72e288a254ec819fb197581a4916d1650c3aa667453285e109c9a61bee3c1b103749ff954de7cb4e340d52e2a74fe1c6bfeb1173ea3c6e53be59afba7de9410b6408e028a7c353c47b69fbf8379983ad3dc26884447c13481466ab2f39b63cb082c5126d8cab509ab6e41c13889b5612a693d306436850c506e9d9ef9ad7b53ec13be89608ea107f6a3690910e44457cdee86c5cba906f3bac813a68716bc95c1aaf42310ba6f1f6b054d5754a3720038ab75517ee6f80731ff72cdf7094bed0305dfb3032f978ba5802e273992ceb384dbdd98a305d4062d9aa01fb2bb5d26af9826fbbb5a2d828249bcaf58eb72f8871573b263c734e7c2dcbd0ab3688b06f5f74acf4d522401659c6c0e159a838c43024274ad7034a77dac1f12792cba4a0abd9880820a418dd60e89f295f7b19c9bc4f17af81008f6d64246f177f993d3d8aaffd3f4ab4d76a75555be3318c284bb3c81fbea9e76a4b1f7cb98790550768f43643d9ca03981def11d0d64e957a01df25ab1e9e75bf5ef11dd6711acfb3a7109b25da5c8783d40741b5c01584fd1a4ba08f1b8796550bc42caa4b41cbd90b9218dfb0f62ca1cc6d6b10aa8fc2ac404218ff335fe72243d0cb14c1b1d9997d9792c6c001628b971db24d43e91ec700e48e00dd485b916eaece2337d5feca12c062f796af4568e61336a20d02eba1be2580f54b543e4e4420fb04667de43448cfaf9bc8872fe5b37208b3a53f423c6ef1abbec351b58bf0c36a063419727fee70321ebd57f69a8e50a299d9032499eddae51180fbd162a516a7a27595414fb78403d80870351f6e250e06168872aca9750cfed6ae6</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">c7w 2021/1/16 15:05:38 读书笔记（bushi<br/>(密码长度119个字符，暴力破解肯定没戏啦，我自己都得复制粘贴进)</span>
      </label>
    </div>
  </div>
</div>
<script src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划的背包问题</title>
    <url>/2020/dp-backpack/</url>
    <content><![CDATA[<p>所以为什么要找一个背包图片当头图啊喂</p>
<h2 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0/1 背包问题"></a>0/1 背包问题</h2><p>有$N$件物品和一个容量为$V$的背包。<strong>每种物品仅有一件，可以选择放或不放。</strong>第$i$件物品的费用是$w[i]$，价值是$c[i]$。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 </p>
<p>设$f[i][v]$表示前$i$件物品(部分或全部)<em>恰</em>放入一个容量为$v$的背包可以获得的最大价值。则其状态转移方程便是：</p>
<script type="math/tex; mode=display">
f[i][v]=\max(f[i-1][v],f[i-1][v-w[i]]+c[i])</script><h3 id="0-1背包的空间优化"><a href="#0-1背包的空间优化" class="headerlink" title="0/1背包的空间优化"></a>0/1背包的空间优化</h3><p>我们可以将二维数组存储优化为一维数组存储。</p>
<p>在每次主循环中，如果我们以$v=V…0$的逆序推$f[v]$，这样就能保证推$f[v]$时$f[v-w[i]]$保存的是状态$f[i-1][v-w[i]]$的值。</p>
<p>伪代码如下：</p>
<pre><code class="lang-c++">for i = 1...N 
    for v = V...0 
        f[v] = max(f[v], f[v-w[i]]+c[i]);
</code></pre>
<p>　　其中$f[v]=max(f[v],f[v-w[i]]+c[i])$便与原转移方程等价。</p>
<h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><p>有$N$种物品和一个容量为$V$的背包，<strong>每种物品都有无限件可用</strong>。第$i$种物品的费用是$w[i]$，价值是$c[i]$。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 </p>
<p>令$f[i][v]$表示前$i$种物品<em>恰</em>放入一个容量为$v$的背包的最大价值，于是可以按照每种物品不同的策略写出状态转移方程：</p>
<script type="math/tex; mode=display">
for \ k\ in \ range[0, floor(\frac v {w[i]})]:\\
 f[i][v]=max(f[i-1][v-k*w[i]]+k*c[i])</script><h3 id="完全背包问题的空间优化"><a href="#完全背包问题的空间优化" class="headerlink" title="完全背包问题的空间优化"></a>完全背包问题的空间优化</h3><p>完全背包的特点恰是每种物品可选无限件，所以我们可以考虑“加选一件第$i$种物品”策略。因此我们可以使用<strong>可能已选入第i种物品</strong>的子结果$f[i][v-w[i]]$，于是我们必须采用$v=0…V$的顺序循环。</p>
<p>伪代码如下：</p>
<pre><code class="lang-c++">for i = 1...N 
    for v = 0...V
        f[v] = max(f[v], f[v-w[i]]+c[i]);
</code></pre>
<h3 id="另一种解法：转化为0-1背包问题"><a href="#另一种解法：转化为0-1背包问题" class="headerlink" title="另一种解法：转化为0/1背包问题"></a>另一种解法：转化为0/1背包问题</h3><p>考虑到第$i$种物品最多选$floor(\frac V {w[i]})$件，于是可以把第$i$种物品转化为$floor(\frac V {w[i]})$件费用及价值均不变的物品，然后求解这个0/1背包问题。</p>
<p>更高效的转化方法是：把第$i$种物品拆成费用为$2^kw[i]$、价值为$2^kc[i]$的若干件物品，其中$k$满足$2^kw[i]&lt;V$。这是二进制的思想，因为不管最优策略选几件第$i$种物品，总可以表示成若干个$2^k$件物品的和。</p>
<h2 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h2><p>有$N$种物品和一个容量为$V$的背包。<strong>第$i$种物品最多有$n[i]$件可用</strong>，每件费用是$w[i]$，价值是$c[i]$。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p>
<p>基本的方程只需将完全背包问题的方程略微一改即可，因为对于第$i$种物品有$n[i]+1$种策略：取$0$件，取$1$件……取$n[i]$件。令$f[i][v]$表示前$i$种物品恰放入一个容量为$v$的背包的最大价值，则：</p>
<script type="math/tex; mode=display">
for \ k\ in \ range[0, n[i]]:\\
f[i][v]=max(f[i-1][v-k*w[i]]+ k*c[i])</script><p>循环时注意$v-k*w[i]$ 非负即可。</p>
<h3 id="转化为0-1背包问题"><a href="#转化为0-1背包问题" class="headerlink" title="转化为0/1背包问题"></a>转化为0/1背包问题</h3><p>将第$i$种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为</p>
<script type="math/tex; mode=display">
1,2,4,...,2^{k-1},n[i]-2^k+1</script><p>且k是满足$n[i]-2^k+1&gt;0$的最大整数。</p>
<p>例如，如果$n[i]$为$13$，就将这种物品分成系数分别为$1,2,4,6$的四件物品。 </p>
<h2 id="二维背包问题"><a href="#二维背包问题" class="headerlink" title="二维背包问题"></a>二维背包问题</h2><p>二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。</p>
<p>设这两种代价分别为代价1和代价2，第$i$件物品所需的两种代价分别为$a[i]$和$b[i]$。两种代价可付出的最大值（两种背包容量）分别为$V$和$U$。物品的价值为$c[i]$。</p>
<p>费用加了一维，只需状态也加一维即可。设$f[i][v][u]$表示前$i$件物品付出两种代价分别恰为$v$和$u$时可获得的最大价值。状态转移方程就是：</p>
<script type="math/tex; mode=display">
f[i][v][u]=max(f[i-1][v][u], f[i-1][v-a[i]][u-b[i]]+c[i])</script><p>如前述方法，可以只使用二维的数组：当每件物品只可以取一次时变量$v$和$u$采用逆序的循环，当物品有如完全背包问题时采用顺序的循环。当物品有如多重背包问题时拆分物品。</p>
<h3 id="物品总个数的限制"><a href="#物品总个数的限制" class="headerlink" title="物品总个数的限制"></a>物品总个数的限制</h3><p>有时，“二维费用”的条件是以这样一种隐含的方式给出的：最多只能取$M$件物品。这事实上相当于每件物品多了一种“件数”的费用，每个物品的件数费用均为$1$，可以付出的最大件数费用为$M$。</p>
<h2 id="咕咕咕"><a href="#咕咕咕" class="headerlink" title="咕咕咕"></a>咕咕咕</h2><p>还有分组背包还有依赖背包但懒得写，源代码也有空再说8</p>
<p>诶mathjax怎么又炸了</p>
<h2 id="Practice"><a href="#Practice" class="headerlink" title="Practice"></a>Practice</h2><ul>
<li><a href="https://www.luogu.com.cn/problem/P1833">https://www.luogu.com.cn/problem/P1833</a></li>
</ul>
<p>附AC代码：</p>
<pre><code class="lang-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;

int v, n=0;
    //  i j   k
int f[1001] = &#123;0&#125;;

int max(int a, int b)&#123;
    return a &gt; b ? a : b;
&#125;

void processTime()&#123;
    int a, b, c, d;
    scanf(&quot;%d:%d %d:%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d);
    v = d - b + (c - a) * 60;
&#125;

void tryItem(int cost, int value, bool inf)&#123;
    if(inf)&#123;
        for (int j = cost; j &lt;= v; j++)&#123;
            f[j] = max(f[j], f[j - cost]+value);
        &#125;
    &#125;else&#123;
        for (int j = v; j &gt;= cost; j--)&#123;
            f[j] = max(f[j], f[j - cost]+value);
        &#125;
    &#125;
&#125;

void decompose(int cost, int value, int num)&#123;
    int base = 1;
    while(num&gt;=base)&#123;
        tryItem(cost * base, value * base, false);
        num -= base;
        base &lt;&lt;= 1;
    &#125;
    if(num&gt;0)&#123;
        tryItem(cost * num, value * num, false);
    &#125;
&#125;

int main()&#123;
    processTime();
    int n;
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++)&#123;
        int a, b, c;
        scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c);
        if(c==0)&#123;
            tryItem(a, b, true);
        &#125;else if(c==1)&#123;
            tryItem(a, b, false);
        &#125;else&#123;
            decompose(a, b, c);
        &#125;
    &#125;
    int result = 0;
    for (int i = 1; i &lt;= v; i++)&#123;
        result = max(result, f[i]);
    &#125;
    cout &lt;&lt; result;
    return 0;
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>dp</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组-入门</title>
    <url>/2020/ds-fenwick-tree-basic/</url>
    <content><![CDATA[<h2 id="Basic-Concept"><a href="#Basic-Concept" class="headerlink" title="Basic Concept"></a>Basic Concept</h2><p>树状数组可以用于高效计算数列的前缀和，区间和等等。</p>
<p>它可以支持在$O(logn)$的时间内得到任意前缀和，以及在$O(logn)$时间内支持对区间单点值的修改。空间复杂度为$O(n)$。</p>
<h3 id="数组存储方式"><a href="#数组存储方式" class="headerlink" title="数组存储方式"></a>数组存储方式</h3><p><img src="https://s3.ax1x.com/2020/12/22/rD8IfS.png" alt="rD8IfS.png"></p>
<p>如图所示。</p>
<p>$A[i]$代表原数组的元素，$C[i]$代表树状数组中的元素。</p>
<pre><code class="lang-c++">C[1]=A[1];
C[2]=A[1]+A[2];
C[3]=A[3];
C[4]=A[1]+A[2]+A[3]+A[4];
C[5]=A[5];
C[6]=A[5]+A[6];
C[7]=A[7];
C[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8];
</code></pre>
<p>而其索引的二进制表示如下：</p>
<pre><code class="lang-c++">C[1] = C[0001] = A[1];
C[2] = C[0010] = A[1]+A[2];
C[3] = C[0011] = A[3];
C[4] = C[0100] = A[1]+A[2]+A[3]+A[4];
C[5] = C[0101] = A[5];
C[6] = C[0110] = A[5]+A[6];
C[7] = C[0111] = A[7];
C[8] = C[1000] = A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8];
</code></pre>
<p>我们可以找出规律，</p>
<script type="math/tex; mode=display">
C[i] =\sum_{k=把i二进制表示的最低位1置为0后，将新的值+1}^i A[k]</script><p>也就是说，问题在于如何找出$i$的最低位$1$所代表的数值。</p>
<h3 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h3><p>这里我们可以引入<code>lowbit</code>函数。</p>
<pre><code class="lang-c++">int lowbit (int x)
&#123;
    return x &amp; (-x);
&#125;
</code></pre>
<p>我们已经知道，对于整数表示，有</p>
<ul>
<li><p>正数的补码是其本身；</p>
</li>
<li><p>负数的补码是在反码的基础上$+1$；</p>
</li>
</ul>
<p>因此<code>x &amp; (-x)</code>就可以满足我们对于查找最低位$1$的需求。</p>
<p>举个例子：</p>
<ul>
<li>二进制数 $11010$ (1) </li>
<li><p>其反码为 $00101$ (2)</p>
</li>
<li><p>加 $1$ 后为 $00110$ (3)</p>
</li>
<li>将(1)(3)两者相与便得到最低位的 $1$ 所表示的数值</li>
</ul>
<h2 id="树状数组的建立"><a href="#树状数组的建立" class="headerlink" title="树状数组的建立"></a>树状数组的建立</h2><p>上面准备工作都做好了，码就行了:(</p>
<pre><code class="lang-c++">#include &lt;iostream&gt;
#define MAXN 12
using namespace std;

int ft[MAXN+1] = &#123;0&#125;;
int a[MAXN + 1] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12&#125;;

int lowbit(int x)&#123;
    return x &amp; (-x);
&#125;

void generateTree()&#123;
    for (int i = 1; i &lt;= MAXN; i++)&#123;
        for (int k = i - lowbit(i) + 1; k &lt;= i; k++)
            ft[i] += a[k];
    &#125;
&#125;

int main()&#123;
    generateTree();
    return 0;
&#125;
</code></pre>
<h2 id="单点更新"><a href="#单点更新" class="headerlink" title="单点更新"></a>单点更新</h2><p>再把这张图拿过来：</p>
<p><img src="https://s3.ax1x.com/2020/12/22/rD8IfS.png" alt="rD8IfS.png"></p>
<p>如果我们要更改$A[3]$的值，那么我们知道，$C[3], C[4], C[8]$ 的值都会受到影响。</p>
<ul>
<li>$3(011)$ =&gt; <code>C[3] += temp;</code></li>
<li>$lowbit(3) = 001$, $3 + lowbit(3)= 100 = 4(100)$ =&gt; <code>C[4] += temp;</code></li>
<li>$lowbit(4) = 100$, $4+lowbit(4)=1000=8(1000)$ =&gt; <code>C[8] += temp;</code></li>
<li>……</li>
</ul>
<p>因此，我们只需要对所要更新的数据不断使其自增lowbit后，</p>
<p>使树状数组的对应索引增加 temp 值即可。</p>
<pre><code class="lang-c++">void update(int index, int val)&#123;
    for (int i = index; i &lt;= MAXN; i = i + lowbit(i))&#123;
        ft[i] += val;
    &#125;
&#125;
</code></pre>
<h2 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h2><p>假设现在我们要查询1~7的前缀和。</p>
<pre><code class="lang-c++">C[7] = C[0111] = A[7];
C[6] = C[0110] = A[5] + A[6];
C[4] = C[0100] = A[1] + A[2] + A[3] + A[4];
</code></pre>
<p>归纳可知，我们只需每次将索引减少i的lowbit，然后将对应的树状数组的值求和即可。</p>
<pre><code class="lang-c++">int getSum(int index)&#123;
    int result = 0;
    for (int k = index; k &gt; 0; k-=lowbit(k))&#123;
        result += ft[k];
    &#125;
    return result;
&#125;
</code></pre>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84">https://zh.wikipedia.org/wiki/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84</a>‘</li>
<li><a href="https://bestsort.cn/2019/04/26/195/">https://bestsort.cn/2019/04/26/195/</a></li>
</ul>
]]></content>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>密码保护文章测试</title>
    <url>/2021/encrypt-test/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="【■■■ - 密码错误 - ■■■】" data-whm="Oh, these decrypted content cannot be verified, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="8712cc481fc34ae6d16ea47f63532ef2acc2c124b33fb3f40c54973de3857f5f">018a63061e17dd91a60e05280129f742932d41a23e2bd96bdb1d48a7faba3ed7b029007f6e466b7ae950fd3977006312fab6bc5ff0c39b2e1bf6c5f37584a15703aba8c89474cb7ce75d3218d2a7d448</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Please complete the sentence: c7w,_______.<br/> You should type in four characters in lowercase.</span>
      </label>
    </div>
  </div>
</div>
<script src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>数据结构-堆</title>
    <url>/2020/ds-heap/</url>
    <content><![CDATA[<p>　　　数据结构中的堆结构　　　</p>
<h2 id="Knowledge-Base"><a href="#Knowledge-Base" class="headerlink" title="Knowledge Base"></a>Knowledge Base</h2><ul>
<li>完全二叉树：</li>
</ul>
<p>​        如果一棵深度为 $k$ 的二叉树，$1$ 至$ k-1$ 层的结点都是满的，即满足 $2^i-1$，只有最下面的一层的结点数小于$2^i-1$，并且最下面一层的结点都集中在该层最左边的若干位置，则此二叉树称为完全二叉树。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>​        堆结构是一种数组对象，它可以被视为一棵完全二叉树。树中每个结点与数组中存放该结点中值的那个元素相对应，如下图：</p>
<p><a href="https://imgchr.com/i/Da1oSH"><img src="https://s3.ax1x.com/2020/11/25/Da1oSH.png" alt="Da1oSH.png"></a></p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul>
<li><p>下标：</p>
<p>​    第$i$个结点的父结点（parent(i)）、左结点(left(i))、右结点(right(i))的下标分别为：$\frac {i}{2}$、$2i$、$2i+1$；</p>
</li>
<li><p>大小：</p>
<p>堆可以分为<strong>最大堆(max-heap)</strong>和<strong>最小堆(min-heap)</strong>两种，分别满足对于任意的$i$, $A[parent(i)] &gt;(&lt;)A[i]$.</p>
</li>
</ul>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ul>
<li><a href="http://www.cplusplus.com/reference/algorithm/make_heap/">make_heap</a></li>
<li><a href="http://www.cplusplus.com/reference/algorithm/push_heap/">push_heap</a></li>
<li><a href="http://www.cplusplus.com/reference/algorithm/pop_heap/">pop_heap</a></li>
</ul>
<h2 id="src"><a href="#src" class="headerlink" title="src"></a>src</h2><pre><code class="lang-c++">//最小堆
class smallHeap &#123;
public:
    int size, maxSize, * head = NULL;

    void init(int depth) &#123;
        int p = qpow(2, depth, 19260817);
        head = new int[p-1];
        maxSize = p - 1;
    &#125;

    smallHeap(int depth) &#123;
        init(depth);
    &#125;

    int getSize() &#123;
        return size;
    &#125;

    bool put(int val) &#123;
        if (size == maxSize) return false;
        size++;
        int currentNode = size; head[currentNode] = val;
        while (currentNode != 1) &#123;
            int parentNode = currentNode / 2;
            if (head[parentNode] &gt; head[currentNode]) &#123;
                int temp = head[parentNode];
                head[parentNode] = head[currentNode];
                head[currentNode] = temp;
                currentNode = parentNode;
            &#125;
            else &#123;
                break;
            &#125;
        &#125;
        return true;
    &#125;

    int get() &#123;
        int currentNode = 1;
        int tempValue = head[currentNode];
        head[currentNode] = head[size];
        size--;
        int parentNode = 1;
        while (1) &#123;
            if (parentNode * 2 &gt; size) break;
            currentNode = (head[parentNode * 2] &lt; head[parentNode * 2 + 1]) ? (parentNode * 2) : (parentNode * 2 + 1);
            if (head[parentNode] &gt; head[currentNode]) &#123;
                int temp = head[parentNode];
                head[parentNode] = head[currentNode];
                head[currentNode] = temp;
                parentNode = currentNode;
            &#125;
            else &#123;
                break;
            &#125;
        &#125;

        return tempValue;
    &#125;

    int top() &#123; return head[1]; &#125;

    void show() &#123;
        for (int i = 1; i &lt;= size; i++) &#123;
            cout &lt;&lt; head[i] &lt;&lt; &quot; &quot;;
        &#125;
    &#125;
&#125;;

//最大堆
class bigHeap &#123;
public:
    int size, maxSize, * head = NULL;

    void init(int depth) &#123;
        int p = qpow(2, depth, 19260817);
        head = new int[p-1];
        maxSize = p - 1;
    &#125;

    bigHeap(int depth) &#123;
        init(depth);
    &#125;

    int getSize() &#123;
        return size;
    &#125;

    bool put(int val) &#123;
        if (size == maxSize) return false;
        size++;
        int currentNode = size; head[currentNode] = val;
        while (currentNode != 1) &#123;
            int parentNode = currentNode / 2;
            if (head[parentNode] &lt; head[currentNode]) &#123;
                int temp = head[parentNode];
                head[parentNode] = head[currentNode];
                head[currentNode] = temp;
                currentNode = parentNode;
            &#125;
            else &#123;
                break;
            &#125;
        &#125;
        return true;
    &#125;

    int get() &#123;
        int currentNode = 1;
        int tempValue = head[currentNode];
        head[currentNode] = head[size];
        size--;
        int parentNode = 1;
        while (1) &#123;
            if (parentNode * 2 &gt; size) break;
            currentNode = (head[parentNode * 2] &gt; head[parentNode * 2 + 1]) ? (parentNode * 2) : (parentNode * 2 + 1);
            if (head[parentNode] &lt; head[currentNode]) &#123;
                int temp = head[parentNode];
                head[parentNode] = head[currentNode];
                head[currentNode] = temp;
                parentNode = currentNode;
            &#125;
            else &#123;
                break;
            &#125;
        &#125;

        return tempValue;
    &#125;

    int top() &#123; return head[1]; &#125;

    void show() &#123;
        for (int i = 1; i &lt;= size; i++) &#123;
            cout &lt;&lt; head[i] &lt;&lt; &quot; &quot;;
        &#125;
    &#125;
&#125;;
</code></pre>
<h2 id="Practice"><a href="#Practice" class="headerlink" title="Practice"></a>Practice</h2><ul>
<li><a href="https://www.luogu.com.cn/problem/P1090">https://www.luogu.com.cn/problem/P1090</a></li>
<li><a href="https://www.luogu.com.cn/problem/P1168">https://www.luogu.com.cn/problem/P1168</a></li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://github.com/raywenderlich/swift-algorithm-club/tree/master/Heap">https://github.com/raywenderlich/swift-algorithm-club/tree/master/Heap</a></li>
<li><a href="http://www.cplusplus.com/reference/algorithm/">http://www.cplusplus.com/reference/algorithm/</a></li>
</ul>
]]></content>
      <tags>
        <tag>Data Structure</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>一些参数方程/极坐标图像</title>
    <url>/2020/figure-of-some-curves/</url>
    <content><![CDATA[<p>菜鸡没学过4-4，在微积分应用里面积面积和体积的时候有的草图画不出来…</p>
<h2 id="星形线"><a href="#星形线" class="headerlink" title="星形线"></a>星形线</h2><script type="math/tex; mode=display">
x^{\frac 2 3}+y^{\frac 2 3}=a^{\frac 2 3} \\
\begin{cases}
x=a\cos^3t\\
y=a\sin^3t
\end{cases}</script><p><img src="https://s3.ax1x.com/2020/12/26/r4AL8K.png" alt=""></p>
<h2 id="摆线"><a href="#摆线" class="headerlink" title="摆线"></a>摆线</h2><script type="math/tex; mode=display">
\begin {cases}
x= a(t-\sin t)\\
y=a(1-\cos t)
\end {cases}</script><p><img src="https://s3.ax1x.com/2020/12/26/r4E12T.png" alt=""></p>
<p>图为$-4\pi \le t \le 4\pi, a=1$的图像.</p>
<p>周期为$2\pi$.</p>
<h2 id="双纽线"><a href="#双纽线" class="headerlink" title="双纽线"></a>双纽线</h2><p><a href="https://imgchr.com/i/r4VeSK"><img src="https://s3.ax1x.com/2020/12/26/r4VeSK.png" alt="r4VeSK.png"></a></p>
<h2 id="笛卡尔心形线"><a href="#笛卡尔心形线" class="headerlink" title="笛卡尔心形线"></a>笛卡尔心形线</h2><p><a href="https://imgchr.com/i/r4ZSht"><img src="https://s3.ax1x.com/2020/12/26/r4ZSht.png" alt="r4ZSht.png"></a></p>
<h2 id="其它曲线"><a href="#其它曲线" class="headerlink" title="其它曲线"></a>其它曲线</h2><p><a href="https://imgchr.com/i/r4ZeNn"><img src="https://s3.ax1x.com/2020/12/26/r4ZeNn.png" alt="r4ZeNn.png"></a></p>
<p><a href="https://imgchr.com/i/r4Zu90"><img src="https://s3.ax1x.com/2020/12/26/r4Zu90.png" alt="r4Zu90.png"></a></p>
<p><a href="https://imgchr.com/i/r4ZK3V"><img src="https://s3.ax1x.com/2020/12/26/r4ZK3V.png" alt="r4ZK3V.png"></a></p>
<p><a href="https://imgchr.com/i/r4ZMcT"><img src="https://s3.ax1x.com/2020/12/26/r4ZMcT.png" alt="r4ZMcT.png"></a></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://mm.edrawsoft.cn/template/65439">https://mm.edrawsoft.cn/template/65439</a></li>
<li>部分图像采用 GeoGebra 绘制</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Hello, World.</title>
    <url>/2020/hello-world/</url>
    <content><![CDATA[<p>没钱结款只得把自己博客搬家的屑</p>
<h2 id="c7w-的破站-ver-2-0"><a href="#c7w-的破站-ver-2-0" class="headerlink" title="c7w 的破站 ver 2.0"></a>c7w 的破站 ver 2.0</h2><p>​        之前用 WordPress 搭的小站快要到期了，现在也不好找免费的虚拟主机薅羊毛，遂借用 github.io + Hexo 搭建本“静态博客”，来记录今后的点滴。</p>
<p><s>         azaz，我打点滴第一候选项是垫底，bksw</s></p>
<p>​        然后强行安利了贵班的文艺委员也用上了这种方法建的博客，甚至还组建了班级的github organisation.</p>
<p>​    等有空了就写博文，咕咕咕</p>
]]></content>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Hash Table（散列表）</title>
    <url>/2020/hash-table/</url>
    <content><![CDATA[<p>　　散列表的相关概念和内容　　</p>
<p>​        <strong>散列表</strong>（<strong>Hash table</strong>，也叫<strong>哈希表</strong>），是根据键（Key）而直接访问在内存储存位置的数据结构。</p>
<p>​        也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。</p>
<p>​        这个映射函数称做<strong>散列函数</strong>，存放记录的数组称做<strong>散列表</strong>。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>关键字为$k$的值存储在$f(k)$的存储位置中，称映射$f$为散列函数，按照这个思想建立的表称为<strong>散列表</strong>。</li>
<li>对不同的关键字可能得到同一散列地址，即$k_1 \neq k_2$，而$f(k_1) = f(k_2)$，这种现象称为<strong>冲突</strong>（Collision）。具有相同函数值的关键字对该散列函数来说称做<strong>同义词</strong>。</li>
<li>若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为<strong>均匀散列函数</strong>，这就使关键字经过散列函数得到一个“随机的地址”，从而减少冲突。</li>
</ul>
<h2 id="构造散列函数的方法"><a href="#构造散列函数的方法" class="headerlink" title="构造散列函数的方法"></a>构造散列函数的方法</h2><p>​        若采用求余的方法，采用质数可以在一定程度上解决冲突问题。</p>
<h2 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h2><ul>
<li>开放定址法</li>
<li>避免聚集：<ul>
<li>单独链表法</li>
<li>再散列</li>
</ul>
</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><p><a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8">https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8</a></p>
</li>
<li><p><a href="https://blog.csdn.net/zmxiangde_88/article/details/8025541">https://blog.csdn.net/zmxiangde_88/article/details/8025541</a></p>
</li>
<li>Computer Science: An Overview, § 9.5 Traditional File Structures.</li>
</ul>
]]></content>
      <tags>
        <tag>Data Structure</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title>同余 逆元 费马小定理</title>
    <url>/2020/inverse-element/</url>
    <content><![CDATA[<p>　　　如果会数学就好了　　　　</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>菜鸡不会打【<a href="https://www.luogu.com.cn/problem/P7108?contestId=13515">P7108</a>】，来补数学知识</p>
<h2 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h2><p>​        给定一个正整数$m$，如果两个整数$a$和$b$满足$a-b$能够被$m$整除，即$(a-b)/m$得到一个整数，那么就称整数$a$与$b$对模$m$同余，记作<script type="math/tex">a≡b(mod m)</script>。</p>
<p>​        对模$m$同余是整数的一个<strong>等价关系</strong>。</p>
<h2 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h2><p>​        如果$p$是一个质数，而整数$a$不是$p$的倍数，则有<script type="math/tex">a^{p-1}≡1（mod p）</script>。</p>
<h2 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h2><script type="math/tex; mode=display">
1\%p=a^{p-1}\%p \\
=> \frac 1 a \% p = a^{p-2}\%p</script><p>​        因此，在计算$\frac{b^h-1}{b-1}$时，我们可以将其转化成$(b^h-1)*inverse(b-1)$计算。</p>
<h2 id="最后有用的代码"><a href="#最后有用的代码" class="headerlink" title="最后有用的代码"></a>最后有用的代码</h2><pre><code class="lang-c++">long long invEl(int x)
&#123;
    return qpow(x, M - 2, M);
&#125;
</code></pre>
<p>【黑人问号脸.jpeg】</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://www.cnblogs.com/kongbursi-2292702937/p/10582258.html">https://www.cnblogs.com/kongbursi-2292702937/p/10582258.html</a></li>
<li><a href="https://baike.baidu.com/item/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/4776158?fr=aladdin">https://baike.baidu.com/item/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/4776158?fr=aladdin</a></li>
</ul>
]]></content>
      <tags>
        <tag>数学</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P1908 求逆序对</title>
    <url>/2020/luogu-P1908/</url>
    <content><![CDATA[<h2 id="归并排序求逆序对数目"><a href="#归并排序求逆序对数目" class="headerlink" title="归并排序求逆序对数目"></a>归并排序求逆序对数目</h2><pre><code class="lang-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;

unsigned long long result = 0;
int a[500001] = &#123;0&#125;;
int cache[500001] = &#123;0&#125;;

void sort(int l, int r)&#123;
    if (r &lt;= l) return;
    if(r-l==1)&#123;
        if(a[l]&gt;a[r])&#123;
            int temp = a[l];
            a[l] = a[r];
            a[r] = temp;
            result++;
        &#125;
        return;
    &#125;
    int mid = (l + r) / 2;
    //[l, mid] &amp;&amp; [mid+1, r]
    sort(l, mid);
    sort(mid + 1, r);
    int len = r - l + 1;
    int x = l, y = mid + 1;
    int pos = 0;
    while(x&lt;=mid &amp;&amp; y&lt;=r)&#123;
        while (x &lt;= mid &amp;&amp; y &lt;= r &amp;&amp; a[x] &lt;= a[y]) &#123;
            pos++;
            cache[pos] = a[x];
            x++;
        &#125;
        if (x &lt;= mid &amp;&amp; y &lt;= r &amp;&amp; a[x] &gt; a[y])&#123;
            pos++;
            cache[pos] = a[y];
            y++;
            result += mid-x+1;
        &#125; 
        if(x&gt;mid)&#123;
            while(y&lt;=r)&#123;
                pos++;
                cache[pos] = a[y];
                y++;
            &#125;
            break;
        &#125;
        if(y&gt;r)&#123;
            while (x&lt;=mid) &#123;
                pos++;
                cache[pos] = a[x];
                x++;
            &#125;
            break;
        &#125;
    &#125;
    for (int i = l; i &lt;= r; i++)&#123;
        a[i] = cache[i - l + 1];
    &#125;
&#125;

int main()&#123;
    int n;
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++)&#123;
        scanf(&quot;%d&quot;, &amp;a[i]);
    &#125;
    sort(1, n);
    cout &lt;&lt; result;
    return 0;
&#125;
</code></pre>
<h2 id="树状数组-离散化求逆序对数目"><a href="#树状数组-离散化求逆序对数目" class="headerlink" title="树状数组+离散化求逆序对数目"></a>树状数组+离散化求逆序对数目</h2><pre><code class="lang-c++">#include &lt;iostream&gt;
#define MAXN 500001
using namespace std;

int n;
unsigned long long result = 0;
int a[MAXN] = &#123;0&#125;;
int ft[MAXN + 1] = &#123;0&#125;;

int lowbit(int x) &#123;
    return x &amp; (-x);
&#125;

void update(int index, int val) &#123;
    for (int i = index; i &lt;= n; i = i + lowbit(i)) &#123;
        ft[i] += val;
    &#125;
&#125;

int getSum(int index) &#123;
    int result = 0;
    for (int k = index; k &gt; 0; k -= lowbit(k)) &#123;
        result += ft[k];
    &#125;
    return result;
&#125;

class entry &#123;
    public:
     int id, val, rank;
&#125; m[500001];

// Last Update: 2020-12-30
/* Quick Sort With CMP Start */
// Sort the element between [a+left, a+right)
// You need to implement the &quot;compare&quot; function.
// You&#39;d better implement a strict inequality in the set.
// An example is given in pseudocode.
/*
bool compare(T A, T B)&#123;
    if(A precedes B)&#123;
        return true;
    &#125;else&#123;
        return false;
    &#125;
&#125;
*/
template &lt;class T&gt;
void quickSort(T* a, int left, int right, bool (*cmp)(T, T)) &#123;
    T pivot = *(a + right - 1);
    int l = left, r = right - 1;
    while (l &lt; r) &#123;
        while (l &lt; r &amp;&amp; !cmp(pivot, a[l])) &#123;  // a[l] &gt;= pivot then continue
            l++;
        &#125;
        while (l &lt; r &amp;&amp; !cmp(a[r], pivot)) &#123;  // a[r] &lt;= pivot then continue
            r--;
        &#125;
        if (l != r) &#123;
            T temp = a[l];
            a[l] = a[r];
            a[r] = temp;
        &#125; else &#123;
            a[right - 1] = a[l];
            a[l] = pivot;
            quickSort(a, left, l, cmp);
            quickSort(a, l + 1, right, cmp);
        &#125;
    &#125;
&#125;
/* Quick Sort With CMP End */

bool compare1(entry a, entry b)&#123;
    if (a.val &lt; b.val) return true;
    if (a.val &gt; b.val) return false;
    if (a.id &lt; b.id) return true;
    return false;
&#125;

bool compare2(entry a, entry b)&#123;
    if (a.id &lt; b.id) return true;
    return false;
&#125;



int main()&#123;
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++)&#123;
        cin &gt;&gt; a[i];
        m[i].id = i;
        m[i].val = a[i]; 
    &#125;
    quickSort(m, 1, n + 1, compare1);
    for (int i = 1; i &lt;= n; i++)&#123;
        m[i].rank = i;
    &#125;
    quickSort(m, 1, n + 1, compare2);
    for (int i = n; i &gt;= 1; i--) &#123;
        update(m[i].rank, 1);
        result = result + getSum(m[i].rank - 1);
    &#125;
    cout &lt;&lt; result;
    return 0;
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>code</tag>
        <tag>luogu</tag>
      </tags>
  </entry>
  <entry>
    <title>合同矩阵与相似矩阵</title>
    <url>/2020/matrix-congruence-and-similarity/</url>
    <content><![CDATA[<h2 id="合同矩阵"><a href="#合同矩阵" class="headerlink" title="合同矩阵"></a>合同矩阵</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>称两矩阵$A,B$合同，当且仅当存在可逆矩阵$C$，使得</p>
<script type="math/tex; mode=display">
A=C^TBC</script><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol>
<li>合同关系是等价关系.</li>
</ol>
<ul>
<li>自反性: $A$与$A$本身合同</li>
<li>对称性: $A$合同于$B$, 则$B$合同于$A$</li>
<li>传递性: $A$合同于$B$, $B$合同于$C$, 则$A$合同于$C$.</li>
</ul>
<ol>
<li>合同矩阵的<strong>秩</strong>相同。</li>
</ol>
<h2 id="相似矩阵"><a href="#相似矩阵" class="headerlink" title="相似矩阵"></a>相似矩阵</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>称两矩阵$A,B$相似，当且仅当存在可逆矩阵$C$，使得</p>
<script type="math/tex; mode=display">
A=C^{-1}BC</script><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><ol>
<li>相似关系是等价关系.</li>
</ol>
<ul>
<li>自反性: $A$与$A$本身相似</li>
<li>对称性: $A$相似于$B$, 则$B$相似于$A$</li>
<li>传递性: $A$相似于$B$, $B$相似于$C$, 则$A$相似于$C$.</li>
</ul>
<ol>
<li>相似矩阵具有一系列相同的特点.</li>
</ol>
<ul>
<li>两者的秩相等；</li>
<li>两者的行列式值相等；</li>
<li>两者的迹相等；</li>
<li>两者拥有同样的特征值，但相应的特征向量一般不同；</li>
<li>两者拥有同样的特征多项式；<br>（我们可以利用这些必要条件来判断两个矩阵是否相似）</li>
</ul>
<ol>
<li>相似矩阵具有相同的可逆性，当它们可逆时，则它们的逆矩阵也相似。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>三角函数的正整数幂的不定积分</title>
    <url>/2020/simple-triangular-indefinite-integral/</url>
    <content><![CDATA[<p>啊说真的排版好麻烦明天再来调吧</p>
<h2 id="Knowledge-Base"><a href="#Knowledge-Base" class="headerlink" title="Knowledge Base"></a>Knowledge Base</h2><ul>
<li>换元法（凑微分法）</li>
</ul>
<script type="math/tex; mode=display">
\int f'(\phi(x))\phi'(x)dx = \int f'(\phi(x))d\phi(x) = f(\phi(x))+C</script><script type="math/tex; mode=display">
\int f'(u)du = \int f'(\phi(x)) \phi'(x)dx = g(x)+C = g(\phi^{-1} (x))+C</script><ul>
<li>分部积分法</li>
</ul>
<h2 id="关于三角函数的幂的积分"><a href="#关于三角函数的幂的积分" class="headerlink" title="关于三角函数的幂的积分"></a>关于三角函数的幂的积分</h2><h3 id="sin-或-cos-的幂"><a href="#sin-或-cos-的幂" class="headerlink" title="sin 或 cos 的幂"></a>sin 或 cos 的幂</h3><p>若指数中存在奇数：</p>
<script type="math/tex; mode=display">
\int \cos^7x \sin^{10}xdx</script><ol>
<li>选定 cos 与 sin 中次幂较低，且为奇数的一个，使用凑微分法</li>
<li>使用公式 $sin^2x+cos^2x=1$ 替换掉剩下的项</li>
</ol>
<p><em>Solve:</em></p>
<script type="math/tex; mode=display">
\begin{aligned}
&\int \cos ^{7} x \sin ^{10} x d x \\
&=\int \cos ^{6} x \sin ^{10} x d \sin x \\
&=\int\left(1-\sin ^{2} x\right)^{3} \sin ^{10} x d \sin x \\
(t &=\sin x) \\
&= \int\left(1-3 t^{2}+3 t^{4}-t^{6}\right) t^{10} d t \\
&=\int\left(t^{10}-3 t^{12}+3 t^{14}-t^{16}\right) d t \\
&=\frac {t^{11}} {11}-\frac{3}{13} t^{13}+\frac{3}{15} t^{15}-\frac{1}{17} t^{17}+C \\
&=\frac{1}{11} \sin ^{11} x-\frac{3}{13} \sin ^{2} x+\frac{1}{5} \sin ^{10} x-\frac{1}{17} \sin ^{17} x+C
\end{aligned}</script><p>若指数中不存在奇数：</p>
<script type="math/tex; mode=display">
\quad \int \cos ^{2} x \sin ^{4} x d x</script><ol>
<li>使用二倍角公式</li>
<li>展开后分别积分</li>
</ol>
<p><em>Solve:</em></p>
<p>$\quad \int \cos ^{2} x \sin ^{4} x d x=\int \frac{1+\cos 2 x}{2} \frac{\left(1-\cos ^{2} x\right)^{2}}{4} d x$<br>$=\frac{1}{8} \int\left(\cos ^{2} 2 x-2 \cos 2 x+1\right)(1+\cos 2 x) d x$<br>$=\frac{1}{8} \int\left(\cos ^{3} 2 x-\cos ^{2} 2 x-\cos 2 x+1\right) d x$<br>$=\frac{1}{8} \int \cos ^{3} 2 x d x-\frac{1}{8} \int \cos ^{2} 2 x d x-\frac{1}{8} \int \cos 2 x d x+\frac{1}{8} \int d x$<br>$=\frac{1}{8} \cdot \frac{1}{2} \int \cos ^{2} 2x d \sin 2 x-\frac{1}{8} \int \frac{1+\cos 4 x}{2} d x-\frac{1}{8} \cdot \frac{1}{2} \sin 2 x+\frac{1}{8} x+C<br>$</p>
<p>$=\frac{1}{16} \int d \sin 2 x-\frac{1}{16} \int \sin ^{2} 2 x d \sin 2 x-\frac{1}{16} x-\frac{1}{16} \cdot \frac{1}{4} \sin 4 x-\frac{1}{16} \sin 2 x+\frac{1}{8} x+C$</p>
<p>$=\frac{x}{16}-\frac{\sin^32x}{48}-\frac{\sin4x}{64}+C$</p>
<h3 id="tan-与-cot-的幂"><a href="#tan-与-cot-的幂" class="headerlink" title="tan 与 cot 的幂"></a>tan 与 cot 的幂</h3><script type="math/tex; mode=display">
\int \tan ^{4} x d x</script><p>使用公式 $ \tan ^{2} x=\sec ^{2} x-1 $</p>
<script type="math/tex; mode=display">
\begin{array}{l}
\int \tan ^{0} x d x=\int d x=x+C \\
\int \tan ^{1} x d x=\int \frac{\sin x}{\cos x} d x=-\int \frac{1}{\cos x} d \cos x=-\ln |\cos x|+C \\
\qquad=\ln |\sec x|+C \\
\end{array}</script><script type="math/tex; mode=display">
\begin{aligned}
I_{n} &=\int \tan ^{n} x d x \\
&=\int \tan ^{n-2} x \tan ^{2} x d x \\
&=\int \tan ^{n-2} x\left(\sec ^{2} x-1\right) d x \\
&=\int \tan ^{n-2} x \sec ^{2} x d x-\int \tan ^{n-2} x d x \\
&=\int \tan ^{n-2} x d \tan x-\int \tan ^{n-2} x d x \\
&=\frac{1}{n-1} \cdot \tan ^{n-1} x-I_{n-2}
\end{aligned}</script><p><em>Solve:</em></p>
<script type="math/tex; mode=display">
\begin{aligned}
\int \tan ^{4} x d x &=\int \tan ^{2} x\left(\sec ^{2} x-1\right) d x \\
&=\int \tan ^{2} x \sec ^{2} x d x-\int \tan ^{2} x d x \\
&=\frac{1}{3} \tan ^{3} x-\int \sec ^{2} x d x+\int d x \\
&=\frac{1}{3} \tan ^{3} x-\tan x+x+C
\end{aligned}</script><p>cot 的幂读者自证不难.</p>
<h3 id="sec-与-csc-的幂"><a href="#sec-与-csc-的幂" class="headerlink" title="sec 与 csc 的幂"></a>sec 与 csc 的幂</h3><script type="math/tex; mode=display">
\begin{aligned}
\int \sec x d x &=\int \frac{(\sec x)(\sec x+\tan x)}{\sec x+\tan x} d x \\
&=\int \frac{\sec x \tan x+\sec ^{2} x}{\sec x+\tan x} d x \\
&=\ln |\sec x+\tan x|+C \\
\int \sec ^{2} x d x &=\tan x+C
\end{aligned}</script><script type="math/tex; mode=display">
\begin{aligned}
\int \sec ^{n} x d x &=\int \sec ^{n-2} x \sec ^{2} x d x \\
&=\int \sec ^{n-2} x d \tan x \\
&=\sec ^{n-2} x \tan x-\int \tan x(n-2) \sec ^{n-3} x \sec x \tan x d x \\
&=\sec ^{n-2} \tan x-(n-2) \int \sec ^{n-2} x \tan ^{2} x d x \\
&=\sec ^{n-2} x \tan x-(n-2) \int \sec ^{n-2} x\left(\sec ^{2} x-1\right) d x \\
&=\sec ^{n-2} x \tan x-(n-2) \int \sec ^{n} x d x+(n-2) \int \sec ^{n-2} x d x \\
\end{aligned}</script><p>因此我们有：</p>
<script type="math/tex; mode=display">
\int \sec ^{n} x d x=\frac{1}{n-1} \sec ^{n-2} x \tan x+\frac{n-2}{n-1} \int \sec ^{n-2} x d x</script><p>csc 的幂同理显然.</p>
]]></content>
      <tags>
        <tag>Calculus</tag>
      </tags>
  </entry>
</search>
