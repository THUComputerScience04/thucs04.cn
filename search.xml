<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据的离散化</title>
    <url>/2020/data-discreatization/</url>
    <content><![CDATA[<h2 id="数据的离散化处理"><a href="#数据的离散化处理" class="headerlink" title="数据的离散化处理"></a>数据的离散化处理</h2><p>什么是<strong>离散化</strong>？</p>
<p>离散化，把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。</p>
<p>通俗的说，离散化是在不改变数据相对大小的条件下，对数据进行相应的缩小。例如：</p>
<ul>
<li><p>原数据：1,999,100000,15；处理后：1,3,4,2；</p>
</li>
<li><p>原数据：{100,200}，{20,50000}，{1,400}；处理后：{3,4}，{2,6}，{1,5}；</p>
</li>
</ul>
<p>例子：洛谷P1908，树状数组求逆序对时的应用</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P1908">https://www.luogu.com.cn/problem/P1908</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>2020-01 日记</title>
    <url>/2021/diary-2021-01/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="【■■■ - 密码错误 - ■■■】" data-whm="Oh, these decrypted content cannot be verified, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="8c90d1c90199cc6384c229df6e5e8bd0d48740dabfaa2ab7077bc0bb852c0722">2827033f81fcfb979d6a35f655f74dad666f139907e7dd6158a7a05612428cef2dc4832a96d82f8600ac7870d88d59f3b217351a137527de34b6171e25e654b99d1dbbbeaf73d719d4c5df94654c37516a690eef29c6363c38771788ca6721a9aa2f73ef42ff831a76ff43e7c95be066d87ef8b427c0cd8e72701800390a6c30a2010e2b0382fa3988ff24b8e3cbe5ab44083143e97f6bde882c62ba7e8fb332143cf952a615a66eec9204e8f1c8fc4fb7d48ac10aeb6c46939976f4364030f6f655f08de9a64be3f5cd1599631617a12c467bcdbd0783915b8a47252bea543a9d8207d2d33321dc7ee4b346271f5f4d2c41bcfedb905820fa5a7275c8f2d20974ba8e30253b4c77520439b79c54e642df9d9358eb55984eda56c9b084084df25eec1105d18ca3d64b47dade2937f670b1ac8f7faa4f44d84f77e003eb4df6fc0e39b14f96071423a3ef17452e21711c9ed950d83cfb9f786d5a0dd6c9094f205f8e6387cc83fff9ff3a2aaceb4152fdeffc6f5da13a628f3a3332a66050c8435cd17c94df3818790f38baf40e87b3b9ecdd188727ce8c5dc9c0c605ab1213bc9684c0c6e8ac76db3f0469c05c89402f77385365bb1de0d5f576918f5224b0bd76f32319958bca75bbbb2b2a207aa7080f7bda948cef595fb92632786c26731219f7f68a863e580edadba79cab5a1f2724e94418e9005b146f312e2093c4fa6670ee5115554bf71aaa27714801535f56ae59b6975ffcfafb52455b2b362eb96097c9ed692db93464e6361e7cc27612c4d30a44b90ce8bd8ccacb9cb0f77265411eaf0b3afc0f96db3bceb89b12b33fdff95dee12aa084027e7f122e8eb11908626e7a69b74f279da118ef35fc474dd15529ef2067d7b8712f51e17d5f83da35d5e1578736644480c96c7b958f1583637303149f26741627f24741e590ba71f0994e1aee525ed2919b0a5d7fe034b57f7f589c78a01cdf74719dad94d07b0cc7d3d1a5509b21d5e78b5cb1d379c63708054b10eac36a1eedbb047f40e364789eac0debc576551d230c0b10744f72a62ac019ff43853dd0764bc247071b4109ab3a22786e2a4cec7ab8d087ad216affcf951e833069ef4c1c96ff326908f925323ba91ffc1b1fb146935a6727f593d06acb8fac0d9aa056f39c409b0b44e37d8b7f3e4801c85efd188bb2c4878ea11eee65aa8ce1fb5b82fcded65f402a493e20ca4afe6f06965402bc90c9ebbacc6fbe7f4d789bee8235d2cad7ae1bc914ba763a69e9f77819e22c0c7ad187ec776247a482411c1c34f3504bcd054a5ede5442749f4d71ab94c64067e6a8d743d22b65854daa7e3ba1e020301abf76f748540870f8b93893886d6816917416832bdc0bfeebb6170d9e224ab69bde386644ed4b5f167dbea5b30adc933872eb72957fac4cbc2f01e017e73ca31328615f67d89792c8a639b4a67199bcc028af38c838e2f4b881088e03cd7fcb4be43808d6a06308f14d35a1eec4283a33089661a5a2e1bdf43e0a426bd3aa545b90e4443a103300a4eb6897bbf30fe463486d769dbe677ca1de70c2a408e8d683cf19216823bcc6e001aeef9ed8859dad3a7be81416adcbaa9bfdad244c4de84ec5fd9ea13d78701b01ce186c9ef988ae025287d574b671f198ff7755eeae4fe8cea2435998a7267f35b85c4983b9075b222dd584993f632030a478ac17725861d3be2dc541cd3e3b4914f69647d725fb76a5e33348dd13e7f06b0c11a1840f5e0625dbae27257100c0f9d7f3ec8b56f64c37e53c01919aeb9b2868c0950e330c00d80530e4b6c2b0148d8d53bcb6a5e2edc322db4d010a8f6a016e8e1eac9655b012e945756091c6acd1d8c028e930aabe675d3e961d2323922dedbad060066677ee2fc95a8126624adce8a6ad54279e32b3fb09a435cca25caa817c85f0ad10bea7f5abc6013618679934ef0c23100cee261cefc52867226b170bd28626a6d3df2d368f43127fcf029e077903ceec4af2f92f9ad833e63ad8d6a5e5b1f5809b73c769ddfaf9daec26a648c2f7a886c619120846937ea333e76c0dd6cbeb5606f321cc94002c3da7c4373bd88992cc611a27e42ec4a3e1565ac7c87825e06d7f453f202be33bbdd1378eb33faefd1b2f7f7aa356f2f1133f8a6597bb1f8a20ee1b57fe98a4ed06f09011c67f80c03f552b156c305e5564897ceb93a6f9a428c93010559e6413e8b5a877c294364b3fe781b2bc61ebfb6463124d82a8d5da511397da13f3a2fe45c9efab553ba0bdb0f1e51c4a98897af19d97b9a672efbe088a3cf6698057c2abc6942b22a956b9d138233e231795661f9f1662c8ea50a50a7b491d6ed98c766c6167ced6f8f9e3a0b00cea6331a07f898d5711355196cc0164fbac1a33acd752ada94e05c70581cd45dd0e708bad79353fc697b5310eb464d0cf3254c3a651cd73ad1090ee1f98c4dcb6f81ad6afa0d53cb84f4151c3ec7fa725cabb0e26a5c4013f9cb41dec3eb863cce3325894274e2a6c4779486d593981387443f95a5f6c1229aa83cce6353383ea6defbfd3a4039ffb221f1369d0fe7f563efefda9cb3f97e7006f597510ef91b8648a6994161ee413c912f44c19126a7178edfce02f680a69459e1641f3047145c6862d02ea6c7c3f710f7182e3213c36c50a9d4b1864a9ffa499d7f563f49dc5a4872e9547cbef6d07b75465c2f51367c90393961c24e710c314941b91cffabdb051cb7ab18b9695ce13385aec6f2eab20167affab1aad8e2ce55008815da612fb9e644b95b8c6fdc819d51c035d7ba652ed8589af63b71d91f25c3042e65902ee1c079d407b3441ee63ed3a91f163628349d0cc75b4530f834e7da8c3d1e87b1ce3077fa68326b44b83f655c06c93be47b43109650d0df242e687c27251690451e46a187b36595ce8357d56f42d8ec05c4d5828b347cd30c7934c90c8abf7f97168969851fd4eb25b63e1bac41e216ad044d223c3ce8ef088c4f46a3a6d7335b623c8d19dbfac270706a70543bd1790ca3752ebba5bc6c01496e3dfa17d02df3055ce8dcd53f1fe77b0b7b8a26a46205810c46df05271ea685fc183e538bdfefd4e20a26abd998aa64d33360b003c69d429249958c0db13667ea62b8a9d163b21cde16cd15fe13d6cf60991a66f6fe46076c77b96ecbb5d53cc19b5da1af2b70049be6c32c1d7778c2d717a2baa4c41a916fb78a3366099e7ba83ff4af65fb0d2a42557dbdf686ab0dad451fb6afc8d658aa2edb11f7a7e07f67dad40cd4a7a2a71ea93d904917a346e55f8990b05813317fc988c204781a62f9edb17eef36360cfb678ea590f69de1795ebc190fffecdf3d7aa876cf2b0f2a875b5302764753e332326ae55dd98689106eab184c5136ece7ed231db339f6fbd91294e6695b3779f824ad61be6cc8a3aad1ff688ccbc5b42404bc328cab2442c7be7e7b4a2ccd9fbb5b018ed5d02f38e6f26738f48709855234839debee7cef0aa947bbe83f7e7ef86ccf4a70620f7805acc030c59af67034c620718dae3c3a8c7e5780f8107214cbaab9b7e32ac3b0abfc722dca569963d3c968a633e5852305472e19d8df9bae75e1280ea51bab47cdfe66cd18f7ca1c044b411c88f0f2ce0f7d952ed3af6c6a68402fb29550c243ed5d60e77ffa28080aae2e85b371307be7e6017ee9432772321b6188b5183ae9831da9905da564f3d1de00695e6c6e324489b8cb14f750e330149904cdc3a86f5cd9830967cbc2fd4d1f191ec95a37f875263fe6e0286e0cb2301a28dfb76e2106b99978d68b260bb5ed7eb982a707cc4073770e342d6e4fa29d6262081689b68d0c4c290825ff22048b55b2b244835c48e815eb32726fc46cd0efeaa984316a4d484666bfc708707c7645c15933a3fe0936cf71140b873c941d41bd8e3c386d8230ba6943b4edae11d2657fca3b777beb5b5e8f6770ae9fb303e5c968bc496527bbddfe916a0fcb8e575290494f720547aea0019ed331c2a1b6151ecdf01d45486f80bc12234527eb40a20ab6788f858ba7d6fd6eff5dbd4c52381de68b9fe2e7d98f4938d6d29fdcebf0371cfc88eecc242ca4772dac1fb154262fff386941352b95bdafdfad734333ea954fe5da76142ad8df59f383c855771ea9dea9e802269145990d1c7f6254b107eb750bc7400b6ac978b87ca5f5da774137e479e1e38c036935fd8282e3f1a20bcf41c7f8eacdb38e87439eaebc005024282f8dbd712a305fe8291d294cdbe847346d212a8be8a7a94cebe234a20453b00aa2c9cbe1a7bf2be2c69be9c21955d62294a35a04967cebc8386738cb374ce8b4dfa9288312eb2161d99765626144b829bd2d750d84a8ba6bffc8d7a71f9ef90653b039d71d169955f4a05e3cc8784b6d635e72f39b4ce234c47de60b13a693d59b602b8c80d0e901e9e2bfecd65b1225bea522da8a75e764e750cfaaea909f9e72460e31abc943c30842e6fd92794538af88149f8ad0ca8f0e3e5fb156a8f0ead59b973a553e6ed4fddb50ebdf1ef1503699f8f283f60b2a54cfeef72902160981997e5b6e9893b4f988b7491ff11d135d1448984034e1fc9c689eaa28c3937fc295296d63b97bb9b315600ff2317b5ba1783aa4820cc9732f9183bd633132e2dbd90883b784540c41819a39a27ff7ecd420b657cb711fb522376d879c277dd156b4738450ee8d6d7c10f1a472adeeeaeb5a53b42206328412e9217c3cb914de63f35b857b8f39d13fa626e8992689943401dad92cc3ee21e1eac1e7faf9d27501516ef2b20f6033a9e87146c48f3e06ac7a48833ee9af21588261c2eb31fa98af6bfa983a7d3ab384bfa851069d6f1594b814c2e1c87c076b66b16ab78636de6d94a49f5a29468b0ec636bd3f5066f2518441679df7e8b3df3be24f44c574500c9922be827be5730654d2f9677a55dfdb99b10464773ce7372ca2738c4499ef7bd2297425986cbd857b9ac0d445d07c6c424aa5659289bfe8c79ae7f8966700d1d844e88599d1a2cde23e73bfe8326df354e8eb990b42708e44be8a801990fdb515d0f0540f8341910b3067af9cbacc73481f5339b9cf37e1a0b50bbe5402cb6c8d7664633a651bf1a57a0df21873c562d5bd4c291925c017818d043c9d2831957230cb28681f059be16908aa89537f8284b4ce3f5a30fc00e05710faa9e75d282ee7f0c3a693561a735b96254bd1a1fd901d6bf43d8b16b7748e15809675d9657482c31eed389ef5d0c204ee84df8ecf33367211d05b96727aa88ce278507bfdc6d136085a70ee90c4bdf2d47d6baa55180d4bf885de007a4583bf01d41858d5405cecb9f04ff375e411e474b945f4da49c34e3d2d2d36b70fe3e468d7c02418195c70f636bd63e9cfe9ef8b5b73a8bda6206981b6f9f8ad0c383b8e166d5ec3ab91de79345be769bdc0b7531a59f8f31ca58b3ba333c3c2f062c1f8a1107646aeed9f9d77293c80c3e974be7d01b77a01266ee08401b327a92264ef2df7c126326d06033ddc80f4d452e03049b9bfc679bb4a2f8fc7b15242394dbb1ae7479c472588b814dd534db27652ea9245242cad20c80a8a64b7beae47d129a803a0d55af0cc4c7d755d16c83d79ecd1d4db1175a6f6a83439781ba8ca9878f0ca46cd315186cf693da2b33b2cb047578f60f387ea0e9877bec01874f493664d7148c49ddaf602c529328847611e4fc8fcf088bac538bd21c4d39339573c6e24cca03ca8c14d6f894d9d2dd56405db5c7bce679abad5e5d290452be22d68f7e77e05f1f693c10107f632c373fe8b378f319946b2ee63af069b45abdd9bda3de3b0bebf477b3023365baed713408b76b05023a0c8a6d3b5439c20f03af9b48cd51b94fb307ea36386115f13e3c5849bb80a95495b5e282d778c154fa06ee7308105de6dd06ee8e92a08e671d032f208b2ad3c7f6d68c4011d8145c400ba41868584fc34050987b68cc7aa8ab7c5e0b3057848070ec38a4826442c9e781deecd0baeb8eccdef14ac89d01e9a79ca4336a9fcdcec33314e01412345c57a51a1ae9eb06233f2c0f63dd2f50d813dd25f2a33f5c5d80bf052d0d341fcca5aeed6f97377d734b7407354f3ae7e250b3fbbc17eb46076d0a2935d32c0a5a35a3499f252a8498098b667c420dd36eeb5d3f9cf69042c9ac8c63a06a787b7e769b62915e9cb1b4de9b431d83d5544dcf1bb9cba0b701f5f50595e9efcadeac015de41bb974b2c120ccda086c6f8f0bb4e62845a692a35e34d73020c751b24e11e9c85e6ce3169ce497784c962be95fece20600e13e307f7227abc83346c585f42d523d0764bcfc96b5e1d2091e6001dc841e4e0ae059489f4304076764b5066cad4cc58923097b905be9b73297831a556678a3e3f4f68c95de7bba42ca8c966d659861292097432cd9ec4b5190349fdf49c4bee69bfd01e65484faacda03935dfd29384fe0b049e162f59bac5be6a9edf5ae5ab8850d9b1b9f9c86f02a4430798557cd905c6d46941ddcec0a581425e3638cd93c1817e5ac5b4ec89628c853b9cc7dce70474676174713511bb1566f7bf9ee0a690e9b76582760f519372a6c97e3c8bc286f7e29a0b05218ffdb2dcfa5b0f662d20e6533ae7de9a5e4f03720f8fb10150920839202027d124a4a9cd7bb84a0df45492f39a20b193216723698c9b3c5022a73e6381d1a4c80f8010c6eded3da89c8d090f92647a696468125b87087267422e4e0e4b41e23a3725ecc932cf89dd31ef22b037bf476ec88883c3d8efd95436ba3e92f59a7bb13566d480caa31e864c1a48065295d406fe6f6bd4b4c86da4231b81586c3049e763a4febcc456d31a6378ad8349fe313f298db484aa41bf2fca21ecf9ca500eeb40f19b148e57ed0240081709624e6015ee29a2a944f8ff88c513e0b31a22af6fd00553394114f84ddb066b5be4de3d92d4d283918fd686525de614b8058aae5b0b4c0f113d1ecf811f91cd3749afdd6e6e7921d36d8e4538054fd21e7bd914acec2af09fc813b3b3e551d6d55a42c8dbe33814eb7ad381a65202ad8d131f5cb797f27718bf855fbaae47d0ddfc09932043fb995eae86c41738030734215b74563dc93ae5455cb622cced52fb3dd4f22890a94dfec7d27b521f208847824ee4fa14e8091132b0172761a84127f0434646b074ac6102dd3f0956faba44012219c1a5a0e7b6272c0a6bd288b20e6ac170f4f2bf91be2d632acd188dff111104ab1e826cfa136009a0c9ec5836abfc4548f1eb5e01138a5f5efec6ca5d2c5d04bb8821138cb5f28f9616af492639ab787131ebfa1ef67fb669a0b1264ba473bfcce04611eebcc510a3c2e7f534bfb464ba7c6a41a7f77d4d8097a15bba6d284c01af8519434457fe2d6ad9f9a48bc571c2403f542e16f75afa0e90142581d2c1c8b1a3f54a8c8f410bc9aa753aee978fc0c578fb6e6ad066ba32bd3526791e7f0c597b677a8ed45c6ceffde4a9974f4629479d340f63a6be5c5d4307179bd4be4ff9efa8f4c74d3951e93c3629fde578fc3d979a85cb06762b6e80799bf75f8a66d53f3ad2c797952d82aa5740ab2cd47cfd6752268de7c6099692ef92ec592b2f9c1edd280f0ad6f2f37e17cda1dc60a19941147410ce102dabdf2dd564b4de2cd2d9d81f7c504497029403db28fc450768ac108a4511c7e06668d04a2d142b7928087214266389778583eb2d0e0ec351a64f274e0f84c20ddf91319c30defa5c68e0f58f9d6537919ada6bfdf1384f32fa46e7979fa5013f0881df770e85ae4568b8527a7c81257c2242aa3d1b23e8be6d873b14337d21ce7e06506d0ee8dade8099a56e81f71e76d1fa3b85ac1c635f0107a94dfc76b195780d80c8d0012f6c541caa6a1005a115e701bcdef01c4dbdafc081297b67c55b33d936706d4ef7eece0bfbfa192b46697d50f371aa193ba8d7ae899174084ba5b46d6652dec612e30ba0ea5562fd2143fed0814b5ff7ca3a3b34703a33fba3c791c1a006734497efcf823171783009957455d72ff26dedeed2aaaca2a0aa0362788ff2abd93161f9da27d07c17760aae1bf38dcf70f98ce7f07f7c7061729c1a7c54f12c565dfe7db56f1cbf18307977bd71da64be32b27e085b2994a402bb0626ab6ec6c9a6108e320fadce0491f749adcede19d063535cb5bd717710b6d954b3560472e966e3db92c1d1c8b79b5a4fb32c697de1a7010ab6306877d41b1472a53e7cf2fb2bda00a9bfb2816066b6a9cf6e5678618519d0e861c74f042bed0edd627a3acb1aac64d6b184db88650fd41eb93f7d45504c1a7704f8b8b4166ced7678756f1db15bc1099d8593d81da44a1af0e7c46f7be951972b4ed5b35f7684e1e218b4a4746ee61fc32a79a0f94965586519f1ec1996e333c8c6ae900f3afd0068c1c457b02a83ba233eecdb2c6d36dd05d30032be767f970c86942fe5cedaa101ee17e11f61cf7922b385aa184507e58470bf4192bf7756c64f4683f3592687d7c6094352e3a5985bdeffcc23762c8df85eeec86298a8cb0b6c46959118ab436eb248c0fa470be065617b688344a29fc1217b9b7635521b9b3299c4ef6ce407087f569394959a3fcb6e20a70d690db314f15d5229f9c4ff52e51385a4ce747a77e7fcd5344a50d6a2ea22a89ebc5d3f50b7a45e6d99dd25a7d4a010b93284a02fe550c99f912cd957217f171848f4881b1a8e72cbe0e5648bb7a50fea2f2e8455eeb7e2ecd8336f97b4e5c8788949179875e03785c58e12798f94c2247325a20d4c91edfd2cd0ef118435733b089d33bc472ee794e0357921d8626fbeb08915fd2ab7bb8998535177370357040af2030441683e93614cc6fd3657fd65108c10724398d79eec8ab72fdbfd78aea4b0a5c631a3e03ef5113f630196c0bc8431f1e5ffd4181ebea1d8ec5aa36d67bf5c417bb327acf6307b10b31d0ad2a82e50ac2a0a1d305ddc3bd0fb44df7c9a754e3fc2df985c8076b199bb41a7bcc4b7f2d071020b2735c5700e1b03a86c3b80552f338d0a1590b6611c9f94321e10d381919addcb96fafdbecc5e20638f1392d0f365b1c8b3b62635b0f3ebd55273a03b99dbcde0ed5bf83a2e8558e7b39a921ac4fa7ceeef19488fe93f1c6615e34504e927430941d32005427a62b4e0e7d9d0a85b09f62e60ce545a1413bd1b58cbdb6a4f7160b1818c06fca702414e0965a20a0824b9461081292d3e34b2dc7227c9109d45a9d424313d08a973af72cd9aa0f9c264eadb83e7349628fd856cea80c6e8b847d7aea6bee7c88354a25ccbed41b8bee5d97c946a31b760afaad1581b862b057f10c8164a6555b23aa51c1ff77a7088ce67df04d97606be25c4c798ec002a2e3ba1832cc5c46f3081ef75b695f395b293d7af7609ba22128e6aacc1a91a84071aefd9b4e8852d890588098bc9e9f542227045586aec5165487046f9435ee171e8bf42380c32ea72bf82250d3df7274cdb949be3bf1fd9d670afcffe96b2c70bd642a83165f5a89889c4a7aefdf78257f81b6a1e5ba2f15eab792fbac58eb7a0fd75f53c18e857b10ba93cbb2fe58df0bb3b48927b49c816393ab777911847df4d0c789ab2139db9c7fe4d69e1d37b033cab037abc2dbe40f2c0a51d2fbe81c4093b0d878c07f0a0c038effd7b5052204fbe07726bbad08533c1308358b34939bd36344714269ce35b702a6e63666c3018954bb0183c26f5f53220f448c1578d45c0874bba300856489ee025554319bb069358e9035455a3fd65da6ded255bbccaf38766f3de5bdd805c3aaf7431dd3523a17603fb5aa8a6d235afa94172c8c608fc7579847d3be970f05c241209d418fbe4c36f4c53d8aa7315699429cb080845bafafd8252387b00cc234823575ad26ee1b0a810948d7ce619d526764c26f74f01932f1b1d9e69821a1c40dcaf57ee416a08728fb9a4899bb5d88279d4b7aee205dfbc68193dfda88726790bb6d0d218817c1050e08e68322f6fcd3429110f1c7712dc6655fc7e0ff766c7eec6c0735144220a93f2547c9a4609e540a57053f743aed822f1071cd86ea01c7c3cb5c58124aa07bf9f85acd2c6d427d0ca0f1baf3f12043d9dd5b88b460dd93aaa29ec43e26828dff00e30bb3e724da27f3146c9e0c1b8c848fbd2a0ad3c9f261948d263d369049ef5b2bb7bacea292f1f5c136133d143d7aa432d9ba767140246f6b798534473d560e48cd1f13a8ac4deaf949ae9935f9586d385ee381d209bb038a06f862731bba06a86679b84972e00b2514bb1c52c8117437630d4f0eda110524f1e101379a9e0f4a75f74e62070a695dbc0c89594eff9d47127dc09e7b32de3ca163c5b7d5f21944543af1f8110055cf0c7906bf2b062c30a3a255c77f796918393fb6eedbca96f8f428fdbfc2c358af7063e51c0935bce779d20a689484f57b708d3515641bad0e0d347ba18e8ed3c1c9221dd85812f09f7dcbd818fba8a2599aa5905157e61d47b099ebd69e24bc79b752f9ba66fee449d104df3ffa400bc141c44f152d3b6efffd40c1c5e2f87c7e35f649b8c6a09c26c5f1b38a7aa1739e69ca91776620f33843872c59380dcb35f145b6297af186e6833243db42c9b7a313c3f4a9c5f9ab966b7ecd85d608c6e5d29e872b962215660b47dfe758d78bb7756e58b824990bb3a349c06fe8565aa88cf121110bcf1752280f331fa43286fc0fa9b4b23e65e9be8962f8693177a82ac6f8dba1ec626aae2aefbe249757b7c6921cdf3732654bae877672414c28c2a51810c10057f9af3b8cedf7cb28a2a35c7dde01ee12994a1df62eaf31531e878b19905b1fac43433b18ad7a155e5f01c6475e37ad8596c36d35d52384b98c6a0fbbf426e6fc67d4021ba9141a4400a37d1efc6ccc14d99b01c21f0b651bf8410cec5bc988247a79182a8cac89a2d74bf8a01cf847ba6cbf2cbc7c46b66a9891d0b8b255d497be4039d020aaba20ec9922e7f670096f7e5f06e2c6ce1fc73a1b290c4fc976ad6421bd18cd8961afadc93dd07879524636d288d022b27082be701a974f7988f0a2e253b6c5766c776f3b50df7bfe23aff43a522052827ad50ec90a0123a250339141e5850f323660c36411c0ab84a7e6ca3a47e75565e82ebbb2c064f80fad16225101e29598bf6b2e5811dfb288f43a4b202f1aa2a635acb67a5c9069653fa8142246cb8544e22dbeb3dbbd9cb090e5dd28210817ebbc287caaa51eb2ef4ce62654307bebe72c1f8c01f061fa21104b65c93bfa3c6ede876aed5bcd0b90aa93dca8a09c0602f8aedd1d1fd2d9a2aaac52bbf118a8dcf5ca913859bc804337f6d46188fffd824abad99dd17bf158a533cf2bfec8302c5570fcad4f2d34c087f5c197ed939ef70122273899c0263e6033ac6444a67f6f3f13754e7b4b928773924f248351c3dfa728ec4dd8e92638db0f4cf31b8746971a1fc24b1101e835159718ebe27795b7520a4bfae7c304181a582cd9dc9976e94578f9e270a90d880ae5197034bea80f2e1aab1b28db1e1a52e6f3c81cc16a6783d89916504958e056ebb62d03d0e1034431c0470162590d409bafb36716867aeca46671c440e12798276e8067a5b47e9317ca4f61b2254a4cbcd60f79c9bfc5024360bef3612662f6699866fe81a7cb277faea725ac7076cdd7f72b10db4a70c612e80a8d8c5e0d6009fb695631d932d729f66fedabdc07e7bf6926dc660dd5980aebe3ac5c30d6bee6aaa32870c30dda8b66e9800c667e3f15e2b4ce0890139893e92ca400658ef8ddc97e835c0cc64446c7ec2f04a9dfc96c437464f17d1c35fd0927c1fd8044638e7c4ae37d00d9cddff675dd2b11d0b9e59d30d2d1d16a701e43c637c65b81c74921e34c9fb2e246b200200a486218ea5f1796cfbb9137526b70416dbc863e3454415c50d9cc948191fddea1c504d500acd9048df140ae4428f97508a14c9c5c156e7315cc9e56274884d42b4ab25f82582c26b389717ac35bb482384aaf4166b080d41b319b5bea40367a1168bb2ded6feef3fec0e0e8a277e7f6bcc3eb45d854187f3663a736b9618f54cd4654446540502fe88a3e2b34b9731a556f9b5966f09ab58706ef8323d22e53fa096a62904d7c9124cb5edbd78007e703344844619200823dea73fd9b548a0c9164f34d4fb1c83397db90291cbd939d38079424e170d31c61d6d1a1c46d4a533ccf45b63f5feb1791a35b61973835fd279d8d017193245d888107fea669749841d14fd4e5aa10ed0b6a992c1e11cf243d6f3c845b7b405d09f89142a61f0891a0d2ffdaf3a75377da9f8526cc59d75823e08b48296e52a784f7010bc24f0c26a69d044a34cfcc46124409d3da9794323aac29c87fa1a5c032b4b64826d0f0ac9a2a62c5cc67a1808dcf1b5480598600997c5629fa50023380d91ec46e73bdd5eff7a938f44046ef297d6da2371bde7d559ce692f758b438c474319bd4f1b12dddc38972f084bda10d9ee1d6a62b12736adc35a80082300ba9c69efc41e7da6adb0b898e76d76b1a551795efd4ff536be00e984fd5dca054d0e938fbd1954777e4253f029b4181918bb941dce1ebc4d20b9439c5f9d164c3560bafd2ee0d250e59084454ee13409496a108318bf470fe38eb5d6f0b7d551b4ef8eedf959d59828ecf5bcf1334ee1e21d24ab5f9920caef6d649ced56c85f012a9a333d551c92899c937cd4144b720d0be5928b2fb27c9fd47948afd8c71f8f73fa3e11dcc69b73315ff6411df5d47330e6e30258de7f11d29c809c15f1a34207c5290e6d1092a16ddbf00babacf9772b597181598da2f760492f95841e66ba4007b69300af0e4fee7694cd469787ae35de58bca9b8e5158447ac0e4d49613219ab12f4e0c3bf5b6b239e68e6a777ee0c3d5309ba5fe157b7cfd57d31870b39ab591e9516cd69bfefad3c6ba6254ef17c7abbcde7b1a82613cf2aaf907adf657a01c539a2f02aec165fadd1ab609e2c686a5ba46e5901108cc33d69b0ef8eeb4248657bac5d4950c4366ad2f3e280232bc88b01b941e18fb26d9b2b837d31d46705525ee52914549cc1c7be65a1182514863d126776471394502a81e033a706e614a1cd3c70f802e0ff80c30d6e239bc63ed92fc7e78f22d033e1e4c01ee67453aa98c50da14127a8454f05cb47a65f3f1f5724622c8d5ab7817942047c18a5b1ac3d3d84c4c6835157956ca6f1056b52a43014ae2a8f54c020856d4c6f34c62c6e3fff092c92d9b8b862d2ac8289f13ba41830dd434f2650a7786d9e54f8ef5acc23f4731fc4b2471263559c72bf9af57196670eab6c8fb33f6bb4df8f9f715904a29d0eef9743be43087c10f6549b773d52ae65dd53a0604e8de93076a28b89dd9cd9e4d7e6bb8c1109b0a8c4617a3043168495c674f1198b37a7a562c32b5819f9512267a47d33de29aa94c0c8a0c360716aa9138c5447f01d8cc4f2cb5543cc64f1052f2880b0e05314d2c7f5df9663c304e17d11541d55a65c4efb1b2b0052c9a6c5c8e7dfce22f724add1f64b14bb7703f8525b943d1160a2708a8709bdd623b43ffc4455d296deaff92b61fba6e254d94753a23b897a66a774afcdfd8775a591e9b8eb4cd45ce8903ccc695025ad8a853cca01bedac1b0bbb5fa1702feda4b0954f446039ef7b3339624bd950c24299da2cfc8b119456cd165762fde31ad8f878559468ee12b78205c3f34799aacdc7248de6485adfe6e3c168aca83e8b8415c1eb8a6e8234896813e2703969de3284f7a70db000ae1043759118d7800f95df923df3eafa85e0adbd761c524fb1d66a54d174b396b47a9da764ac00137796d9ec49020466b6c4e0ca9c770e565461bf3aa468b274c2fbf4b4a9681629b3fc7e63413ebb08b9da8d6c297dbdac06aed97490f9ea32236ddaa024998c1e67406f272d8bc6fd13ade5bec9b699274469e070e3f947ea6a894368b92115a593c3da6cacbf29a48bc7ea445455f1311eb298789e01427f1e3315c9ae81df0e09333450148774a4500791170c8e0d64bdf6308f61a5bd79ddfd28b38c7d8ca57f047a48c8751411bee2dce877c8bf7416b2dc4ebf4af1dc5ece092221358b66bf66e53fce4a8ed04bb803965334f4fcfe67b76570d531357a2bbf86e63dfe0afabd55395054fc9105d28461e7b299792c63ac8c130e2a2947dc19f996b214948fc174d6ef1370869954179afc58b925476c73ab4c05ba0696d249507c81a4f3ba785607a6c654f6dcb65a26ff4bf2ff2b18d4890a22285351c32da2539af5158f3d1640a613ad7efee2d9f79ef0517adc39fb3cab1c2a58ab896b6d00e8ebe2c4bc72d4e56178a88092f8d</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">c7w 2021/1/16 15:05:38 读书笔记（bushi<br/>(密码长度119个字符，暴力破解肯定没戏啦，我自己都得复制粘贴进)</span>
      </label>
    </div>
  </div>
</div>
<script src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划的背包问题</title>
    <url>/2020/dp-backpack/</url>
    <content><![CDATA[<p>所以为什么要找一个背包图片当头图啊喂</p>
<h2 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0/1 背包问题"></a>0/1 背包问题</h2><p>有$N$件物品和一个容量为$V$的背包。<strong>每种物品仅有一件，可以选择放或不放。</strong>第$i$件物品的费用是$w[i]$，价值是$c[i]$。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 </p>
<p>设$f[i][v]$表示前$i$件物品(部分或全部)<em>恰</em>放入一个容量为$v$的背包可以获得的最大价值。则其状态转移方程便是：</p>
<script type="math/tex; mode=display">
f[i][v]=\max(f[i-1][v],f[i-1][v-w[i]]+c[i])</script><h3 id="0-1背包的空间优化"><a href="#0-1背包的空间优化" class="headerlink" title="0/1背包的空间优化"></a>0/1背包的空间优化</h3><p>我们可以将二维数组存储优化为一维数组存储。</p>
<p>在每次主循环中，如果我们以$v=V…0$的逆序推$f[v]$，这样就能保证推$f[v]$时$f[v-w[i]]$保存的是状态$f[i-1][v-w[i]]$的值。</p>
<p>伪代码如下：</p>
<pre><code class="lang-c++">for i = 1...N 
    for v = V...0 
        f[v] = max(f[v], f[v-w[i]]+c[i]);
</code></pre>
<p>　　其中$f[v]=max(f[v],f[v-w[i]]+c[i])$便与原转移方程等价。</p>
<h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><p>有$N$种物品和一个容量为$V$的背包，<strong>每种物品都有无限件可用</strong>。第$i$种物品的费用是$w[i]$，价值是$c[i]$。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 </p>
<p>令$f[i][v]$表示前$i$种物品<em>恰</em>放入一个容量为$v$的背包的最大价值，于是可以按照每种物品不同的策略写出状态转移方程：</p>
<script type="math/tex; mode=display">
for \ k\ in \ range[0, floor(\frac v {w[i]})]:\\
 f[i][v]=max(f[i-1][v-k*w[i]]+k*c[i])</script><h3 id="完全背包问题的空间优化"><a href="#完全背包问题的空间优化" class="headerlink" title="完全背包问题的空间优化"></a>完全背包问题的空间优化</h3><p>完全背包的特点恰是每种物品可选无限件，所以我们可以考虑“加选一件第$i$种物品”策略。因此我们可以使用<strong>可能已选入第i种物品</strong>的子结果$f[i][v-w[i]]$，于是我们必须采用$v=0…V$的顺序循环。</p>
<p>伪代码如下：</p>
<pre><code class="lang-c++">for i = 1...N 
    for v = 0...V
        f[v] = max(f[v], f[v-w[i]]+c[i]);
</code></pre>
<h3 id="另一种解法：转化为0-1背包问题"><a href="#另一种解法：转化为0-1背包问题" class="headerlink" title="另一种解法：转化为0/1背包问题"></a>另一种解法：转化为0/1背包问题</h3><p>考虑到第$i$种物品最多选$floor(\frac V {w[i]})$件，于是可以把第$i$种物品转化为$floor(\frac V {w[i]})$件费用及价值均不变的物品，然后求解这个0/1背包问题。</p>
<p>更高效的转化方法是：把第$i$种物品拆成费用为$2^kw[i]$、价值为$2^kc[i]$的若干件物品，其中$k$满足$2^kw[i]&lt;V$。这是二进制的思想，因为不管最优策略选几件第$i$种物品，总可以表示成若干个$2^k$件物品的和。</p>
<h2 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h2><p>有$N$种物品和一个容量为$V$的背包。<strong>第$i$种物品最多有$n[i]$件可用</strong>，每件费用是$w[i]$，价值是$c[i]$。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p>
<p>基本的方程只需将完全背包问题的方程略微一改即可，因为对于第$i$种物品有$n[i]+1$种策略：取$0$件，取$1$件……取$n[i]$件。令$f[i][v]$表示前$i$种物品恰放入一个容量为$v$的背包的最大价值，则：</p>
<script type="math/tex; mode=display">
for \ k\ in \ range[0, n[i]]:\\
f[i][v]=max(f[i-1][v-k*w[i]]+ k*c[i])</script><p>循环时注意$v-k*w[i]$ 非负即可。</p>
<h3 id="转化为0-1背包问题"><a href="#转化为0-1背包问题" class="headerlink" title="转化为0/1背包问题"></a>转化为0/1背包问题</h3><p>将第$i$种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为</p>
<script type="math/tex; mode=display">
1,2,4,...,2^{k-1},n[i]-2^k+1</script><p>且k是满足$n[i]-2^k+1&gt;0$的最大整数。</p>
<p>例如，如果$n[i]$为$13$，就将这种物品分成系数分别为$1,2,4,6$的四件物品。 </p>
<h2 id="二维背包问题"><a href="#二维背包问题" class="headerlink" title="二维背包问题"></a>二维背包问题</h2><p>二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。</p>
<p>设这两种代价分别为代价1和代价2，第$i$件物品所需的两种代价分别为$a[i]$和$b[i]$。两种代价可付出的最大值（两种背包容量）分别为$V$和$U$。物品的价值为$c[i]$。</p>
<p>费用加了一维，只需状态也加一维即可。设$f[i][v][u]$表示前$i$件物品付出两种代价分别恰为$v$和$u$时可获得的最大价值。状态转移方程就是：</p>
<script type="math/tex; mode=display">
f[i][v][u]=max(f[i-1][v][u], f[i-1][v-a[i]][u-b[i]]+c[i])</script><p>如前述方法，可以只使用二维的数组：当每件物品只可以取一次时变量$v$和$u$采用逆序的循环，当物品有如完全背包问题时采用顺序的循环。当物品有如多重背包问题时拆分物品。</p>
<h3 id="物品总个数的限制"><a href="#物品总个数的限制" class="headerlink" title="物品总个数的限制"></a>物品总个数的限制</h3><p>有时，“二维费用”的条件是以这样一种隐含的方式给出的：最多只能取$M$件物品。这事实上相当于每件物品多了一种“件数”的费用，每个物品的件数费用均为$1$，可以付出的最大件数费用为$M$。</p>
<h2 id="咕咕咕"><a href="#咕咕咕" class="headerlink" title="咕咕咕"></a>咕咕咕</h2><p>还有分组背包还有依赖背包但懒得写，源代码也有空再说8</p>
<p>诶mathjax怎么又炸了</p>
<h2 id="Practice"><a href="#Practice" class="headerlink" title="Practice"></a>Practice</h2><ul>
<li><a href="https://www.luogu.com.cn/problem/P1833">https://www.luogu.com.cn/problem/P1833</a></li>
</ul>
<p>附AC代码：</p>
<pre><code class="lang-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;

int v, n=0;
    //  i j   k
int f[1001] = &#123;0&#125;;

int max(int a, int b)&#123;
    return a &gt; b ? a : b;
&#125;

void processTime()&#123;
    int a, b, c, d;
    scanf(&quot;%d:%d %d:%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d);
    v = d - b + (c - a) * 60;
&#125;

void tryItem(int cost, int value, bool inf)&#123;
    if(inf)&#123;
        for (int j = cost; j &lt;= v; j++)&#123;
            f[j] = max(f[j], f[j - cost]+value);
        &#125;
    &#125;else&#123;
        for (int j = v; j &gt;= cost; j--)&#123;
            f[j] = max(f[j], f[j - cost]+value);
        &#125;
    &#125;
&#125;

void decompose(int cost, int value, int num)&#123;
    int base = 1;
    while(num&gt;=base)&#123;
        tryItem(cost * base, value * base, false);
        num -= base;
        base &lt;&lt;= 1;
    &#125;
    if(num&gt;0)&#123;
        tryItem(cost * num, value * num, false);
    &#125;
&#125;

int main()&#123;
    processTime();
    int n;
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++)&#123;
        int a, b, c;
        scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c);
        if(c==0)&#123;
            tryItem(a, b, true);
        &#125;else if(c==1)&#123;
            tryItem(a, b, false);
        &#125;else&#123;
            decompose(a, b, c);
        &#125;
    &#125;
    int result = 0;
    for (int i = 1; i &lt;= v; i++)&#123;
        result = max(result, f[i]);
    &#125;
    cout &lt;&lt; result;
    return 0;
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>dp</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组-入门</title>
    <url>/2020/ds-fenwick-tree-basic/</url>
    <content><![CDATA[<h2 id="Basic-Concept"><a href="#Basic-Concept" class="headerlink" title="Basic Concept"></a>Basic Concept</h2><p>树状数组可以用于高效计算数列的前缀和，区间和等等。</p>
<p>它可以支持在$O(logn)$的时间内得到任意前缀和，以及在$O(logn)$时间内支持对区间单点值的修改。空间复杂度为$O(n)$。</p>
<h3 id="数组存储方式"><a href="#数组存储方式" class="headerlink" title="数组存储方式"></a>数组存储方式</h3><p><img src="https://s3.ax1x.com/2020/12/22/rD8IfS.png" alt="rD8IfS.png"></p>
<p>如图所示。</p>
<p>$A[i]$代表原数组的元素，$C[i]$代表树状数组中的元素。</p>
<pre><code class="lang-c++">C[1]=A[1];
C[2]=A[1]+A[2];
C[3]=A[3];
C[4]=A[1]+A[2]+A[3]+A[4];
C[5]=A[5];
C[6]=A[5]+A[6];
C[7]=A[7];
C[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8];
</code></pre>
<p>而其索引的二进制表示如下：</p>
<pre><code class="lang-c++">C[1] = C[0001] = A[1];
C[2] = C[0010] = A[1]+A[2];
C[3] = C[0011] = A[3];
C[4] = C[0100] = A[1]+A[2]+A[3]+A[4];
C[5] = C[0101] = A[5];
C[6] = C[0110] = A[5]+A[6];
C[7] = C[0111] = A[7];
C[8] = C[1000] = A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8];
</code></pre>
<p>我们可以找出规律，</p>
<script type="math/tex; mode=display">
C[i] =\sum_{k=把i二进制表示的最低位1置为0后，将新的值+1}^i A[k]</script><p>也就是说，问题在于如何找出$i$的最低位$1$所代表的数值。</p>
<h3 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h3><p>这里我们可以引入<code>lowbit</code>函数。</p>
<pre><code class="lang-c++">int lowbit (int x)
&#123;
    return x &amp; (-x);
&#125;
</code></pre>
<p>我们已经知道，对于整数表示，有</p>
<ul>
<li><p>正数的补码是其本身；</p>
</li>
<li><p>负数的补码是在反码的基础上$+1$；</p>
</li>
</ul>
<p>因此<code>x &amp; (-x)</code>就可以满足我们对于查找最低位$1$的需求。</p>
<p>举个例子：</p>
<ul>
<li>二进制数 $11010$ (1) </li>
<li><p>其反码为 $00101$ (2)</p>
</li>
<li><p>加 $1$ 后为 $00110$ (3)</p>
</li>
<li>将(1)(3)两者相与便得到最低位的 $1$ 所表示的数值</li>
</ul>
<h2 id="树状数组的建立"><a href="#树状数组的建立" class="headerlink" title="树状数组的建立"></a>树状数组的建立</h2><p>上面准备工作都做好了，码就行了:(</p>
<pre><code class="lang-c++">#include &lt;iostream&gt;
#define MAXN 12
using namespace std;

int ft[MAXN+1] = &#123;0&#125;;
int a[MAXN + 1] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12&#125;;

int lowbit(int x)&#123;
    return x &amp; (-x);
&#125;

void generateTree()&#123;
    for (int i = 1; i &lt;= MAXN; i++)&#123;
        for (int k = i - lowbit(i) + 1; k &lt;= i; k++)
            ft[i] += a[k];
    &#125;
&#125;

int main()&#123;
    generateTree();
    return 0;
&#125;
</code></pre>
<h2 id="单点更新"><a href="#单点更新" class="headerlink" title="单点更新"></a>单点更新</h2><p>再把这张图拿过来：</p>
<p><img src="https://s3.ax1x.com/2020/12/22/rD8IfS.png" alt="rD8IfS.png"></p>
<p>如果我们要更改$A[3]$的值，那么我们知道，$C[3], C[4], C[8]$ 的值都会受到影响。</p>
<ul>
<li>$3(011)$ =&gt; <code>C[3] += temp;</code></li>
<li>$lowbit(3) = 001$, $3 + lowbit(3)= 100 = 4(100)$ =&gt; <code>C[4] += temp;</code></li>
<li>$lowbit(4) = 100$, $4+lowbit(4)=1000=8(1000)$ =&gt; <code>C[8] += temp;</code></li>
<li>……</li>
</ul>
<p>因此，我们只需要对所要更新的数据不断使其自增lowbit后，</p>
<p>使树状数组的对应索引增加 temp 值即可。</p>
<pre><code class="lang-c++">void update(int index, int val)&#123;
    for (int i = index; i &lt;= MAXN; i = i + lowbit(i))&#123;
        ft[i] += val;
    &#125;
&#125;
</code></pre>
<h2 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h2><p>假设现在我们要查询1~7的前缀和。</p>
<pre><code class="lang-c++">C[7] = C[0111] = A[7];
C[6] = C[0110] = A[5] + A[6];
C[4] = C[0100] = A[1] + A[2] + A[3] + A[4];
</code></pre>
<p>归纳可知，我们只需每次将索引减少i的lowbit，然后将对应的树状数组的值求和即可。</p>
<pre><code class="lang-c++">int getSum(int index)&#123;
    int result = 0;
    for (int k = index; k &gt; 0; k-=lowbit(k))&#123;
        result += ft[k];
    &#125;
    return result;
&#125;
</code></pre>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84">https://zh.wikipedia.org/wiki/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84</a>‘</li>
<li><a href="https://bestsort.cn/2019/04/26/195/">https://bestsort.cn/2019/04/26/195/</a></li>
</ul>
]]></content>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-堆</title>
    <url>/2020/ds-heap/</url>
    <content><![CDATA[<p>　　　数据结构中的堆结构　　　</p>
<h2 id="Knowledge-Base"><a href="#Knowledge-Base" class="headerlink" title="Knowledge Base"></a>Knowledge Base</h2><ul>
<li>完全二叉树：</li>
</ul>
<p>​        如果一棵深度为 $k$ 的二叉树，$1$ 至$ k-1$ 层的结点都是满的，即满足 $2^i-1$，只有最下面的一层的结点数小于$2^i-1$，并且最下面一层的结点都集中在该层最左边的若干位置，则此二叉树称为完全二叉树。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>​        堆结构是一种数组对象，它可以被视为一棵完全二叉树。树中每个结点与数组中存放该结点中值的那个元素相对应，如下图：</p>
<p><a href="https://imgchr.com/i/Da1oSH"><img src="https://s3.ax1x.com/2020/11/25/Da1oSH.png" alt="Da1oSH.png"></a></p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul>
<li><p>下标：</p>
<p>​    第$i$个结点的父结点（parent(i)）、左结点(left(i))、右结点(right(i))的下标分别为：$\frac {i}{2}$、$2i$、$2i+1$；</p>
</li>
<li><p>大小：</p>
<p>堆可以分为<strong>最大堆(max-heap)</strong>和<strong>最小堆(min-heap)</strong>两种，分别满足对于任意的$i$, $A[parent(i)] &gt;(&lt;)A[i]$.</p>
</li>
</ul>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ul>
<li><a href="http://www.cplusplus.com/reference/algorithm/make_heap/">make_heap</a></li>
<li><a href="http://www.cplusplus.com/reference/algorithm/push_heap/">push_heap</a></li>
<li><a href="http://www.cplusplus.com/reference/algorithm/pop_heap/">pop_heap</a></li>
</ul>
<h2 id="src"><a href="#src" class="headerlink" title="src"></a>src</h2><pre><code class="lang-c++">//最小堆
class smallHeap &#123;
public:
    int size, maxSize, * head = NULL;

    void init(int depth) &#123;
        int p = qpow(2, depth, 19260817);
        head = new int[p-1];
        maxSize = p - 1;
    &#125;

    smallHeap(int depth) &#123;
        init(depth);
    &#125;

    int getSize() &#123;
        return size;
    &#125;

    bool put(int val) &#123;
        if (size == maxSize) return false;
        size++;
        int currentNode = size; head[currentNode] = val;
        while (currentNode != 1) &#123;
            int parentNode = currentNode / 2;
            if (head[parentNode] &gt; head[currentNode]) &#123;
                int temp = head[parentNode];
                head[parentNode] = head[currentNode];
                head[currentNode] = temp;
                currentNode = parentNode;
            &#125;
            else &#123;
                break;
            &#125;
        &#125;
        return true;
    &#125;

    int get() &#123;
        int currentNode = 1;
        int tempValue = head[currentNode];
        head[currentNode] = head[size];
        size--;
        int parentNode = 1;
        while (1) &#123;
            if (parentNode * 2 &gt; size) break;
            currentNode = (head[parentNode * 2] &lt; head[parentNode * 2 + 1]) ? (parentNode * 2) : (parentNode * 2 + 1);
            if (head[parentNode] &gt; head[currentNode]) &#123;
                int temp = head[parentNode];
                head[parentNode] = head[currentNode];
                head[currentNode] = temp;
                parentNode = currentNode;
            &#125;
            else &#123;
                break;
            &#125;
        &#125;

        return tempValue;
    &#125;

    int top() &#123; return head[1]; &#125;

    void show() &#123;
        for (int i = 1; i &lt;= size; i++) &#123;
            cout &lt;&lt; head[i] &lt;&lt; &quot; &quot;;
        &#125;
    &#125;
&#125;;

//最大堆
class bigHeap &#123;
public:
    int size, maxSize, * head = NULL;

    void init(int depth) &#123;
        int p = qpow(2, depth, 19260817);
        head = new int[p-1];
        maxSize = p - 1;
    &#125;

    bigHeap(int depth) &#123;
        init(depth);
    &#125;

    int getSize() &#123;
        return size;
    &#125;

    bool put(int val) &#123;
        if (size == maxSize) return false;
        size++;
        int currentNode = size; head[currentNode] = val;
        while (currentNode != 1) &#123;
            int parentNode = currentNode / 2;
            if (head[parentNode] &lt; head[currentNode]) &#123;
                int temp = head[parentNode];
                head[parentNode] = head[currentNode];
                head[currentNode] = temp;
                currentNode = parentNode;
            &#125;
            else &#123;
                break;
            &#125;
        &#125;
        return true;
    &#125;

    int get() &#123;
        int currentNode = 1;
        int tempValue = head[currentNode];
        head[currentNode] = head[size];
        size--;
        int parentNode = 1;
        while (1) &#123;
            if (parentNode * 2 &gt; size) break;
            currentNode = (head[parentNode * 2] &gt; head[parentNode * 2 + 1]) ? (parentNode * 2) : (parentNode * 2 + 1);
            if (head[parentNode] &lt; head[currentNode]) &#123;
                int temp = head[parentNode];
                head[parentNode] = head[currentNode];
                head[currentNode] = temp;
                parentNode = currentNode;
            &#125;
            else &#123;
                break;
            &#125;
        &#125;

        return tempValue;
    &#125;

    int top() &#123; return head[1]; &#125;

    void show() &#123;
        for (int i = 1; i &lt;= size; i++) &#123;
            cout &lt;&lt; head[i] &lt;&lt; &quot; &quot;;
        &#125;
    &#125;
&#125;;
</code></pre>
<h2 id="Practice"><a href="#Practice" class="headerlink" title="Practice"></a>Practice</h2><ul>
<li><a href="https://www.luogu.com.cn/problem/P1090">https://www.luogu.com.cn/problem/P1090</a></li>
<li><a href="https://www.luogu.com.cn/problem/P1168">https://www.luogu.com.cn/problem/P1168</a></li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://github.com/raywenderlich/swift-algorithm-club/tree/master/Heap">https://github.com/raywenderlich/swift-algorithm-club/tree/master/Heap</a></li>
<li><a href="http://www.cplusplus.com/reference/algorithm/">http://www.cplusplus.com/reference/algorithm/</a></li>
</ul>
]]></content>
      <tags>
        <tag>Data Structure</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>一些参数方程/极坐标图像</title>
    <url>/2020/figure-of-some-curves/</url>
    <content><![CDATA[<p>菜鸡没学过4-4，在微积分应用里面积面积和体积的时候有的草图画不出来…</p>
<h2 id="星形线"><a href="#星形线" class="headerlink" title="星形线"></a>星形线</h2><script type="math/tex; mode=display">
x^{\frac 2 3}+y^{\frac 2 3}=a^{\frac 2 3} \\
\begin{cases}
x=a\cos^3t\\
y=a\sin^3t
\end{cases}</script><p><img src="https://s3.ax1x.com/2020/12/26/r4AL8K.png" alt=""></p>
<h2 id="摆线"><a href="#摆线" class="headerlink" title="摆线"></a>摆线</h2><script type="math/tex; mode=display">
\begin {cases}
x= a(t-\sin t)\\
y=a(1-\cos t)
\end {cases}</script><p><img src="https://s3.ax1x.com/2020/12/26/r4E12T.png" alt=""></p>
<p>图为$-4\pi \le t \le 4\pi, a=1$的图像.</p>
<p>周期为$2\pi$.</p>
<h2 id="双纽线"><a href="#双纽线" class="headerlink" title="双纽线"></a>双纽线</h2><p><a href="https://imgchr.com/i/r4VeSK"><img src="https://s3.ax1x.com/2020/12/26/r4VeSK.png" alt="r4VeSK.png"></a></p>
<h2 id="笛卡尔心形线"><a href="#笛卡尔心形线" class="headerlink" title="笛卡尔心形线"></a>笛卡尔心形线</h2><p><a href="https://imgchr.com/i/r4ZSht"><img src="https://s3.ax1x.com/2020/12/26/r4ZSht.png" alt="r4ZSht.png"></a></p>
<h2 id="其它曲线"><a href="#其它曲线" class="headerlink" title="其它曲线"></a>其它曲线</h2><p><a href="https://imgchr.com/i/r4ZeNn"><img src="https://s3.ax1x.com/2020/12/26/r4ZeNn.png" alt="r4ZeNn.png"></a></p>
<p><a href="https://imgchr.com/i/r4Zu90"><img src="https://s3.ax1x.com/2020/12/26/r4Zu90.png" alt="r4Zu90.png"></a></p>
<p><a href="https://imgchr.com/i/r4ZK3V"><img src="https://s3.ax1x.com/2020/12/26/r4ZK3V.png" alt="r4ZK3V.png"></a></p>
<p><a href="https://imgchr.com/i/r4ZMcT"><img src="https://s3.ax1x.com/2020/12/26/r4ZMcT.png" alt="r4ZMcT.png"></a></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://mm.edrawsoft.cn/template/65439">https://mm.edrawsoft.cn/template/65439</a></li>
<li>部分图像采用 GeoGebra 绘制</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>密码保护文章测试</title>
    <url>/2021/encrypt-test/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="【■■■ - 密码错误 - ■■■】" data-whm="Oh, these decrypted content cannot be verified, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="8712cc481fc34ae6d16ea47f63532ef2acc2c124b33fb3f40c54973de3857f5f">018a63061e17dd91a60e05280129f742932d41a23e2bd96bdb1d48a7faba3ed7b029007f6e466b7ae950fd3977006312fab6bc5ff0c39b2e1bf6c5f37584a15703aba8c89474cb7ce75d3218d2a7d448</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Please complete the sentence: c7w,_______.<br/> You should type in four characters in lowercase.</span>
      </label>
    </div>
  </div>
</div>
<script src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>Hash Table（散列表）</title>
    <url>/2020/hash-table/</url>
    <content><![CDATA[<p>　　散列表的相关概念和内容　　</p>
<p>​        <strong>散列表</strong>（<strong>Hash table</strong>，也叫<strong>哈希表</strong>），是根据键（Key）而直接访问在内存储存位置的数据结构。</p>
<p>​        也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。</p>
<p>​        这个映射函数称做<strong>散列函数</strong>，存放记录的数组称做<strong>散列表</strong>。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>关键字为$k$的值存储在$f(k)$的存储位置中，称映射$f$为散列函数，按照这个思想建立的表称为<strong>散列表</strong>。</li>
<li>对不同的关键字可能得到同一散列地址，即$k_1 \neq k_2$，而$f(k_1) = f(k_2)$，这种现象称为<strong>冲突</strong>（Collision）。具有相同函数值的关键字对该散列函数来说称做<strong>同义词</strong>。</li>
<li>若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为<strong>均匀散列函数</strong>，这就使关键字经过散列函数得到一个“随机的地址”，从而减少冲突。</li>
</ul>
<h2 id="构造散列函数的方法"><a href="#构造散列函数的方法" class="headerlink" title="构造散列函数的方法"></a>构造散列函数的方法</h2><p>​        若采用求余的方法，采用质数可以在一定程度上解决冲突问题。</p>
<h2 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h2><ul>
<li>开放定址法</li>
<li>避免聚集：<ul>
<li>单独链表法</li>
<li>再散列</li>
</ul>
</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><p><a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8">https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8</a></p>
</li>
<li><p><a href="https://blog.csdn.net/zmxiangde_88/article/details/8025541">https://blog.csdn.net/zmxiangde_88/article/details/8025541</a></p>
</li>
<li>Computer Science: An Overview, § 9.5 Traditional File Structures.</li>
</ul>
]]></content>
      <tags>
        <tag>Data Structure</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello, World.</title>
    <url>/2020/hello-world/</url>
    <content><![CDATA[<p>没钱结款只得把自己博客搬家的屑</p>
<h2 id="c7w-的破站-ver-2-0"><a href="#c7w-的破站-ver-2-0" class="headerlink" title="c7w 的破站 ver 2.0"></a>c7w 的破站 ver 2.0</h2><p>​        之前用 WordPress 搭的小站快要到期了，现在也不好找免费的虚拟主机薅羊毛，遂借用 github.io + Hexo 搭建本“静态博客”，来记录今后的点滴。</p>
<p><s>         azaz，我打点滴第一候选项是垫底，bksw</s></p>
<p>​        然后强行安利了贵班的文艺委员也用上了这种方法建的博客，甚至还组建了班级的github organisation.</p>
<p>​    等有空了就写博文，咕咕咕</p>
]]></content>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>同余 逆元 费马小定理</title>
    <url>/2020/inverse-element/</url>
    <content><![CDATA[<p>　　　如果会数学就好了　　　　</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>菜鸡不会打【<a href="https://www.luogu.com.cn/problem/P7108?contestId=13515">P7108</a>】，来补数学知识</p>
<h2 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h2><p>​        给定一个正整数$m$，如果两个整数$a$和$b$满足$a-b$能够被$m$整除，即$(a-b)/m$得到一个整数，那么就称整数$a$与$b$对模$m$同余，记作<script type="math/tex">a≡b(mod m)</script>。</p>
<p>​        对模$m$同余是整数的一个<strong>等价关系</strong>。</p>
<h2 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h2><p>​        如果$p$是一个质数，而整数$a$不是$p$的倍数，则有<script type="math/tex">a^{p-1}≡1（mod p）</script>。</p>
<h2 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h2><script type="math/tex; mode=display">
1\%p=a^{p-1}\%p \\
=> \frac 1 a \% p = a^{p-2}\%p</script><p>​        因此，在计算$\frac{b^h-1}{b-1}$时，我们可以将其转化成$(b^h-1)*inverse(b-1)$计算。</p>
<h2 id="最后有用的代码"><a href="#最后有用的代码" class="headerlink" title="最后有用的代码"></a>最后有用的代码</h2><pre><code class="lang-c++">long long invEl(int x)
&#123;
    return qpow(x, M - 2, M);
&#125;
</code></pre>
<p>【黑人问号脸.jpeg】</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://www.cnblogs.com/kongbursi-2292702937/p/10582258.html">https://www.cnblogs.com/kongbursi-2292702937/p/10582258.html</a></li>
<li><a href="https://baike.baidu.com/item/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/4776158?fr=aladdin">https://baike.baidu.com/item/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/4776158?fr=aladdin</a></li>
</ul>
]]></content>
      <tags>
        <tag>数学</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P1908 求逆序对</title>
    <url>/2020/luogu-P1908/</url>
    <content><![CDATA[<h2 id="归并排序求逆序对数目"><a href="#归并排序求逆序对数目" class="headerlink" title="归并排序求逆序对数目"></a>归并排序求逆序对数目</h2><pre><code class="lang-c++">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;

unsigned long long result = 0;
int a[500001] = &#123;0&#125;;
int cache[500001] = &#123;0&#125;;

void sort(int l, int r)&#123;
    if (r &lt;= l) return;
    if(r-l==1)&#123;
        if(a[l]&gt;a[r])&#123;
            int temp = a[l];
            a[l] = a[r];
            a[r] = temp;
            result++;
        &#125;
        return;
    &#125;
    int mid = (l + r) / 2;
    //[l, mid] &amp;&amp; [mid+1, r]
    sort(l, mid);
    sort(mid + 1, r);
    int len = r - l + 1;
    int x = l, y = mid + 1;
    int pos = 0;
    while(x&lt;=mid &amp;&amp; y&lt;=r)&#123;
        while (x &lt;= mid &amp;&amp; y &lt;= r &amp;&amp; a[x] &lt;= a[y]) &#123;
            pos++;
            cache[pos] = a[x];
            x++;
        &#125;
        if (x &lt;= mid &amp;&amp; y &lt;= r &amp;&amp; a[x] &gt; a[y])&#123;
            pos++;
            cache[pos] = a[y];
            y++;
            result += mid-x+1;
        &#125; 
        if(x&gt;mid)&#123;
            while(y&lt;=r)&#123;
                pos++;
                cache[pos] = a[y];
                y++;
            &#125;
            break;
        &#125;
        if(y&gt;r)&#123;
            while (x&lt;=mid) &#123;
                pos++;
                cache[pos] = a[x];
                x++;
            &#125;
            break;
        &#125;
    &#125;
    for (int i = l; i &lt;= r; i++)&#123;
        a[i] = cache[i - l + 1];
    &#125;
&#125;

int main()&#123;
    int n;
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++)&#123;
        scanf(&quot;%d&quot;, &amp;a[i]);
    &#125;
    sort(1, n);
    cout &lt;&lt; result;
    return 0;
&#125;
</code></pre>
<h2 id="树状数组-离散化求逆序对数目"><a href="#树状数组-离散化求逆序对数目" class="headerlink" title="树状数组+离散化求逆序对数目"></a>树状数组+离散化求逆序对数目</h2><pre><code class="lang-c++">#include &lt;iostream&gt;
#define MAXN 500001
using namespace std;

int n;
unsigned long long result = 0;
int a[MAXN] = &#123;0&#125;;
int ft[MAXN + 1] = &#123;0&#125;;

int lowbit(int x) &#123;
    return x &amp; (-x);
&#125;

void update(int index, int val) &#123;
    for (int i = index; i &lt;= n; i = i + lowbit(i)) &#123;
        ft[i] += val;
    &#125;
&#125;

int getSum(int index) &#123;
    int result = 0;
    for (int k = index; k &gt; 0; k -= lowbit(k)) &#123;
        result += ft[k];
    &#125;
    return result;
&#125;

class entry &#123;
    public:
     int id, val, rank;
&#125; m[500001];

// Last Update: 2020-12-30
/* Quick Sort With CMP Start */
// Sort the element between [a+left, a+right)
// You need to implement the &quot;compare&quot; function.
// You&#39;d better implement a strict inequality in the set.
// An example is given in pseudocode.
/*
bool compare(T A, T B)&#123;
    if(A precedes B)&#123;
        return true;
    &#125;else&#123;
        return false;
    &#125;
&#125;
*/
template &lt;class T&gt;
void quickSort(T* a, int left, int right, bool (*cmp)(T, T)) &#123;
    T pivot = *(a + right - 1);
    int l = left, r = right - 1;
    while (l &lt; r) &#123;
        while (l &lt; r &amp;&amp; !cmp(pivot, a[l])) &#123;  // a[l] &gt;= pivot then continue
            l++;
        &#125;
        while (l &lt; r &amp;&amp; !cmp(a[r], pivot)) &#123;  // a[r] &lt;= pivot then continue
            r--;
        &#125;
        if (l != r) &#123;
            T temp = a[l];
            a[l] = a[r];
            a[r] = temp;
        &#125; else &#123;
            a[right - 1] = a[l];
            a[l] = pivot;
            quickSort(a, left, l, cmp);
            quickSort(a, l + 1, right, cmp);
        &#125;
    &#125;
&#125;
/* Quick Sort With CMP End */

bool compare1(entry a, entry b)&#123;
    if (a.val &lt; b.val) return true;
    if (a.val &gt; b.val) return false;
    if (a.id &lt; b.id) return true;
    return false;
&#125;

bool compare2(entry a, entry b)&#123;
    if (a.id &lt; b.id) return true;
    return false;
&#125;



int main()&#123;
    cin &gt;&gt; n;
    for (int i = 1; i &lt;= n; i++)&#123;
        cin &gt;&gt; a[i];
        m[i].id = i;
        m[i].val = a[i]; 
    &#125;
    quickSort(m, 1, n + 1, compare1);
    for (int i = 1; i &lt;= n; i++)&#123;
        m[i].rank = i;
    &#125;
    quickSort(m, 1, n + 1, compare2);
    for (int i = n; i &gt;= 1; i--) &#123;
        update(m[i].rank, 1);
        result = result + getSum(m[i].rank - 1);
    &#125;
    cout &lt;&lt; result;
    return 0;
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>code</tag>
        <tag>luogu</tag>
      </tags>
  </entry>
  <entry>
    <title>合同矩阵与相似矩阵</title>
    <url>/2020/matrix-congruence-and-similarity/</url>
    <content><![CDATA[<h2 id="合同矩阵"><a href="#合同矩阵" class="headerlink" title="合同矩阵"></a>合同矩阵</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>称两矩阵$A,B$合同，当且仅当存在可逆矩阵$C$，使得</p>
<script type="math/tex; mode=display">
A=C^TBC</script><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol>
<li>合同关系是等价关系.</li>
</ol>
<ul>
<li>自反性: $A$与$A$本身合同</li>
<li>对称性: $A$合同于$B$, 则$B$合同于$A$</li>
<li>传递性: $A$合同于$B$, $B$合同于$C$, 则$A$合同于$C$.</li>
</ul>
<ol>
<li>合同矩阵的<strong>秩</strong>相同。</li>
</ol>
<h2 id="相似矩阵"><a href="#相似矩阵" class="headerlink" title="相似矩阵"></a>相似矩阵</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>称两矩阵$A,B$相似，当且仅当存在可逆矩阵$C$，使得</p>
<script type="math/tex; mode=display">
A=C^{-1}BC</script><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><ol>
<li>相似关系是等价关系.</li>
</ol>
<ul>
<li>自反性: $A$与$A$本身相似</li>
<li>对称性: $A$相似于$B$, 则$B$相似于$A$</li>
<li>传递性: $A$相似于$B$, $B$相似于$C$, 则$A$相似于$C$.</li>
</ul>
<ol>
<li>相似矩阵具有一系列相同的特点.</li>
</ol>
<ul>
<li>两者的秩相等；</li>
<li>两者的行列式值相等；</li>
<li>两者的迹相等；</li>
<li>两者拥有同样的特征值，但相应的特征向量一般不同；</li>
<li>两者拥有同样的特征多项式；<br>（我们可以利用这些必要条件来判断两个矩阵是否相似）</li>
</ul>
<ol>
<li>相似矩阵具有相同的可逆性，当它们可逆时，则它们的逆矩阵也相似。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>三角函数的正整数幂的不定积分</title>
    <url>/2020/simple-triangular-indefinite-integral/</url>
    <content><![CDATA[<p>啊说真的排版好麻烦明天再来调吧</p>
<h2 id="Knowledge-Base"><a href="#Knowledge-Base" class="headerlink" title="Knowledge Base"></a>Knowledge Base</h2><ul>
<li>换元法（凑微分法）</li>
</ul>
<script type="math/tex; mode=display">
\int f'(\phi(x))\phi'(x)dx = \int f'(\phi(x))d\phi(x) = f(\phi(x))+C</script><script type="math/tex; mode=display">
\int f'(u)du = \int f'(\phi(x)) \phi'(x)dx = g(x)+C = g(\phi^{-1} (x))+C</script><ul>
<li>分部积分法</li>
</ul>
<h2 id="关于三角函数的幂的积分"><a href="#关于三角函数的幂的积分" class="headerlink" title="关于三角函数的幂的积分"></a>关于三角函数的幂的积分</h2><h3 id="sin-或-cos-的幂"><a href="#sin-或-cos-的幂" class="headerlink" title="sin 或 cos 的幂"></a>sin 或 cos 的幂</h3><p>若指数中存在奇数：</p>
<script type="math/tex; mode=display">
\int \cos^7x \sin^{10}xdx</script><ol>
<li>选定 cos 与 sin 中次幂较低，且为奇数的一个，使用凑微分法</li>
<li>使用公式 $sin^2x+cos^2x=1$ 替换掉剩下的项</li>
</ol>
<p><em>Solve:</em></p>
<script type="math/tex; mode=display">
\begin{aligned}
&\int \cos ^{7} x \sin ^{10} x d x \\
&=\int \cos ^{6} x \sin ^{10} x d \sin x \\
&=\int\left(1-\sin ^{2} x\right)^{3} \sin ^{10} x d \sin x \\
(t &=\sin x) \\
&= \int\left(1-3 t^{2}+3 t^{4}-t^{6}\right) t^{10} d t \\
&=\int\left(t^{10}-3 t^{12}+3 t^{14}-t^{16}\right) d t \\
&=\frac {t^{11}} {11}-\frac{3}{13} t^{13}+\frac{3}{15} t^{15}-\frac{1}{17} t^{17}+C \\
&=\frac{1}{11} \sin ^{11} x-\frac{3}{13} \sin ^{2} x+\frac{1}{5} \sin ^{10} x-\frac{1}{17} \sin ^{17} x+C
\end{aligned}</script><p>若指数中不存在奇数：</p>
<script type="math/tex; mode=display">
\quad \int \cos ^{2} x \sin ^{4} x d x</script><ol>
<li>使用二倍角公式</li>
<li>展开后分别积分</li>
</ol>
<p><em>Solve:</em></p>
<p>$\quad \int \cos ^{2} x \sin ^{4} x d x=\int \frac{1+\cos 2 x}{2} \frac{\left(1-\cos ^{2} x\right)^{2}}{4} d x$<br>$=\frac{1}{8} \int\left(\cos ^{2} 2 x-2 \cos 2 x+1\right)(1+\cos 2 x) d x$<br>$=\frac{1}{8} \int\left(\cos ^{3} 2 x-\cos ^{2} 2 x-\cos 2 x+1\right) d x$<br>$=\frac{1}{8} \int \cos ^{3} 2 x d x-\frac{1}{8} \int \cos ^{2} 2 x d x-\frac{1}{8} \int \cos 2 x d x+\frac{1}{8} \int d x$<br>$=\frac{1}{8} \cdot \frac{1}{2} \int \cos ^{2} 2x d \sin 2 x-\frac{1}{8} \int \frac{1+\cos 4 x}{2} d x-\frac{1}{8} \cdot \frac{1}{2} \sin 2 x+\frac{1}{8} x+C<br>$</p>
<p>$=\frac{1}{16} \int d \sin 2 x-\frac{1}{16} \int \sin ^{2} 2 x d \sin 2 x-\frac{1}{16} x-\frac{1}{16} \cdot \frac{1}{4} \sin 4 x-\frac{1}{16} \sin 2 x+\frac{1}{8} x+C$</p>
<p>$=\frac{x}{16}-\frac{\sin^32x}{48}-\frac{\sin4x}{64}+C$</p>
<h3 id="tan-与-cot-的幂"><a href="#tan-与-cot-的幂" class="headerlink" title="tan 与 cot 的幂"></a>tan 与 cot 的幂</h3><script type="math/tex; mode=display">
\int \tan ^{4} x d x</script><p>使用公式 $ \tan ^{2} x=\sec ^{2} x-1 $</p>
<script type="math/tex; mode=display">
\begin{array}{l}
\int \tan ^{0} x d x=\int d x=x+C \\
\int \tan ^{1} x d x=\int \frac{\sin x}{\cos x} d x=-\int \frac{1}{\cos x} d \cos x=-\ln |\cos x|+C \\
\qquad=\ln |\sec x|+C \\
\end{array}</script><script type="math/tex; mode=display">
\begin{aligned}
I_{n} &=\int \tan ^{n} x d x \\
&=\int \tan ^{n-2} x \tan ^{2} x d x \\
&=\int \tan ^{n-2} x\left(\sec ^{2} x-1\right) d x \\
&=\int \tan ^{n-2} x \sec ^{2} x d x-\int \tan ^{n-2} x d x \\
&=\int \tan ^{n-2} x d \tan x-\int \tan ^{n-2} x d x \\
&=\frac{1}{n-1} \cdot \tan ^{n-1} x-I_{n-2}
\end{aligned}</script><p><em>Solve:</em></p>
<script type="math/tex; mode=display">
\begin{aligned}
\int \tan ^{4} x d x &=\int \tan ^{2} x\left(\sec ^{2} x-1\right) d x \\
&=\int \tan ^{2} x \sec ^{2} x d x-\int \tan ^{2} x d x \\
&=\frac{1}{3} \tan ^{3} x-\int \sec ^{2} x d x+\int d x \\
&=\frac{1}{3} \tan ^{3} x-\tan x+x+C
\end{aligned}</script><p>cot 的幂读者自证不难.</p>
<h3 id="sec-与-csc-的幂"><a href="#sec-与-csc-的幂" class="headerlink" title="sec 与 csc 的幂"></a>sec 与 csc 的幂</h3><script type="math/tex; mode=display">
\begin{aligned}
\int \sec x d x &=\int \frac{(\sec x)(\sec x+\tan x)}{\sec x+\tan x} d x \\
&=\int \frac{\sec x \tan x+\sec ^{2} x}{\sec x+\tan x} d x \\
&=\ln |\sec x+\tan x|+C \\
\int \sec ^{2} x d x &=\tan x+C
\end{aligned}</script><script type="math/tex; mode=display">
\begin{aligned}
\int \sec ^{n} x d x &=\int \sec ^{n-2} x \sec ^{2} x d x \\
&=\int \sec ^{n-2} x d \tan x \\
&=\sec ^{n-2} x \tan x-\int \tan x(n-2) \sec ^{n-3} x \sec x \tan x d x \\
&=\sec ^{n-2} \tan x-(n-2) \int \sec ^{n-2} x \tan ^{2} x d x \\
&=\sec ^{n-2} x \tan x-(n-2) \int \sec ^{n-2} x\left(\sec ^{2} x-1\right) d x \\
&=\sec ^{n-2} x \tan x-(n-2) \int \sec ^{n} x d x+(n-2) \int \sec ^{n-2} x d x \\
\end{aligned}</script><p>因此我们有：</p>
<script type="math/tex; mode=display">
\int \sec ^{n} x d x=\frac{1}{n-1} \sec ^{n-2} x \tan x+\frac{n-2}{n-1} \int \sec ^{n-2} x d x</script><p>csc 的幂同理显然.</p>
]]></content>
      <tags>
        <tag>Calculus</tag>
      </tags>
  </entry>
</search>
